<?xml version="1.0" encoding="UTF-8"?>
<Appendix><Heading>Contributions</Heading>


<Section><Heading>Functions implemented by A. Sammartano</Heading>

<ManSection>
                    <Prop Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupBuchsbaum"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns true if the graded ring associated to <M>K[[<A>S</A>]]</M>
                        is Buchsbaum, and false otherwise.
                        This test is the implementation of the algorithm given in <Cite Key="DA-M-M"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
                    </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="TorsionOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the set of elements in the numerical semigroup <A>S</A> corresponding to a <M>\mathbb{K}</M>-basis of the torsion submodule of the associated graded ring of the numerical semigroup ring <M>\mathbb{K}[\![S]\!]</M>. It uses the Apery table as explained in <Cite Key="CJZ"></Cite>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TorsionOfAssociatedGradedRingNumericalSemigroup(s);
[ 181, 153, 157, 193, 169, 148 ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="S" Name="BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the smallest non-negative integer <M>k</M> for which the associated graded ring <M>G</M> of a given numerical semigroup ring is <M>k</M>-Buchsbaum, that is, the least <M>k</M> for which the torsion submodule of <M>G</M> is annihilated by the <M>k</M>-th power of the homogeneous maximal ideal of <M>G</M>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup(s);
1
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
                    <Prop Arg="S" Name="IsMpure"></Prop>
                    <Prop Arg="S" Name="IsMpureNumericalSemigroup"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the M-Purity of the numerical semigroup S <A>S</A>.
			This test is based on
                        <Cite Key="Br"></Cite>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsMpureNumericalSemigroup(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsMpureNumericalSemigroup(s);
true
]]></Example>
                    </Description>
                </ManSection>



<ManSection>
                    <Prop Arg="S" Name="IsPure"></Prop>
                    <Prop Arg="S" Name="IsPureNumericalSemigroup"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the purity of the numerical semigroup S <A>S</A>.
			This test is based on
                        <Cite Key="Br"></Cite>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsPureNumericalSemigroup(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsPureNumericalSemigroup(s);
true
]]></Example>
                    </Description>
</ManSection>


<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupGorenstein"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns true if the graded ring associated to <M>K[[<A>S</A>]]</M>
                        is Gorenstein, and false otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DA-M-S"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
true
]]></Example>
                    </Description>
</ManSection>

<!--the functions below first appeared in version 0.98-->
<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCI"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns true if the Complete Intersection property of the associated graded ring of a numerical semigroup ring associated to <M>K[[<A>S</A>]]</M>, and false otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSwhen"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
true
]]></Example>
                    </Description>
                </ManSection>
<ManSection>
                    <Func Arg="S" Name="IsAperySetGammaRectangular"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the Gamma-Rectangularity of the Apéry Set of a numerical semigroup.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSClasses"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsAperySetGammaRectangular(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsAperySetGammaRectangular(s);
true
]]></Example>
                    </Description>
                </ManSection>
<ManSection>
                    <Func Arg="S" Name="IsAperySetBetaRectangular"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the Beta-Rectangularity of the Apéry Set of a numerical semigroup.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSClasses"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsAperySetBetaRectangular(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsAperySetBetaRectangular(s);
true
]]></Example>
                    </Description>
                </ManSection>
<ManSection>
                    <Func Arg="S" Name="IsAperySetAlphaRectangular"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the Alpha-Rectangularity of the Apéry Set of a numerical semigroup.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSClasses"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsAperySetAlphaRectangular(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsAperySetAlphaRectangular(s);
true
]]></Example>
                    </Description>
</ManSection>

<ManSection>
                    <Func Arg="S" Name="TypeSequenceOfNumericalSemigroup"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                         Computes the type sequence of a numerical semigroup.
                        This test is the implementation of the algorithm given in
                        <Cite Key="BDF97"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TypeSequenceOfNumericalSemigroup(s);
[ 13, 3, 4, 4, 7, 3, 3, 3, 2, 2, 2, 3, 3, 2, 4, 3, 2, 1, 3, 2, 1, 1, 2, 2, 1,
  1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
  1, 1, 1 ]
gap> s:=NumericalSemigroup(4,6,11);;
gap> TypeSequenceOfNumericalSemigroup(s);
[ 1, 1, 1, 1, 1, 1, 1 ]
]]></Example>
                    </Description>
</ManSection>



</Section>

<Section><Heading>Functions implemented by C. O'Neill</Heading>

This section includes the implementations of some procedures described in <Cite Key="B-P-ON"></Cite>.

<ManSection>
                    <Func Arg="l,S" Name="OmegaPrimalityOfElementListInNumericalSemigroup"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup and <A>l</A> a list of elements of <A>S</A>.
                        <P/>

                         Computes the omega-values of all the elements in <A>l</A>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> l:=FirstElementsOfNumericalSemigroup(100,s);;
gap> List(l,x->OmegaPrimalityOfElementInNumericalSemigroup(x,s)); time;
[ 0, 4, 5, 5, 4, 6, 7, 6, 6, 6, 6, 7, 8, 7, 7, 7, 7, 7, 8, 7, 8, 9, 8, 8, 8,
  8, 8, 8, 8, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 11, 10, 10, 10, 10, 10,
  10, 10, 10, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 12, 12, 12, 12,
  12, 12, 12, 12, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 14, 14, 14,
  14, 14, 14, 14, 14, 15, 16, 15, 15, 15, 15, 15, 15, 15, 15 ]
218
gap> OmegaPrimalityOfElementListInNumericalSemigroup(l,s);time;
[ 0, 4, 5, 5, 4, 6, 7, 6, 6, 6, 6, 7, 8, 7, 7, 7, 7, 7, 8, 7, 8, 9, 8, 8, 8,
  8, 8, 8, 8, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 11, 10, 10, 10, 10, 10,
  10, 10, 10, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 12, 12, 12, 12,
  12, 12, 12, 12, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 14, 14, 14,
  14, 14, 14, 14, 14, 15, 16, 15, 15, 15, 15, 15, 15, 15, 15 ]
10
]]></Example>
                    </Description>
                </ManSection>

<ManSection>
  <Func Arg="l,S" Name="FactorizationsElementListWRTNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup and <A>l</A> a list of elements of <A>S</A>.
    <P/>

    Computes the factorizations of all the elements in <A>l</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);
<Numerical semigroup with 3 generators>
gap> FactorizationsElementListWRTNumericalSemigroup([100,101,103],s);
[ [ [ 0, 2, 6 ], [ 1, 7, 1 ], [ 3, 4, 2 ], [ 5, 1, 3 ], [ 10, 0, 0 ] ],
  [ [ 0, 8, 1 ], [ 1, 0, 7 ], [ 2, 5, 2 ], [ 4, 2, 3 ], [ 9, 1, 0 ] ],
  [ [ 0, 7, 2 ], [ 2, 4, 3 ], [ 4, 1, 4 ], [ 7, 3, 0 ], [ 9, 0, 1 ] ] ]

]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="DeltaSetPeriodicityBoundForNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    Computes the bound were the periodicity starts for Delta sets of the elements in <A>S</A>; see <Cite Key="GG-MF-VT"></Cite>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,11);;
gap> DeltaSetPeriodicityBoundForNumericalSemigroup(s);
60
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="DeltaSetPeriodicityStartForNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    Computes the element were the periodicity starts for Delta sets of the elements in <A>S</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,11);;
gap> DeltaSetPeriodicityStartForNumericalSemigroup(s);
21
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="n, S" Name="DeltaSetListUpToElementWRTNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup, <A>n</A> a nonnegative integer.
    <P/>

    Computes the Delta sets of the integers up to (and including) <A>n</A>, if an integer is not in <A>S</A>, the corresponding Delta set is empty.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,11);;
gap> DeltaSetListUpToElementWRTNumericalSemigroup(31,s);
[ [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ],
  [  ], [  ], [  ], [  ], [  ], [  ], [  ], [  ], [ 2 ], [  ], [  ], [ 2 ], [  ],
  [ 2 ], [  ], [ 2 ], [ 2 ], [  ] ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="n, S" Name="DeltaSetUnionUpToElementWRTNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup, <A>n</A> a nonnegative integer.
    <P/>


    Computes the union of the delta sets of the elements of <A>S</A> up to and including <A>n</A>, using a ring buffer to conserve memory.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,11);;
gap> DeltaSetUnionUpToElementWRTNumericalSemigroup(60,s);
[ 2 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="DeltaSetOfNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    Computes the Delta set of <A>S</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,11);;
gap> DeltaSetOfNumericalSemigroup(s);
[ 2 ]
]]></Example>
  </Description>
</ManSection>

</Section>

<Section><Heading>Functions implemented by K. Stokes</Heading>

In this section we document the functions implemented by K. Stokes related to patterns of ideals in numerical semigroups. The correctness of the algorithms can be found in <Cite Key="Stokes"></Cite>.


<ManSection>
  <Func Arg="p" Name="IsAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns true or false depending if the pattern is admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,1,-1]);
true
gap> IsAdmissiblePattern([1,-2]);
false
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p" Name="IsStronglyAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns true or false depending if the pattern is strongly admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,-1]);
true
gap> IsStronglyAdmissiblePattern([1,-1]);
false
gap> IsStronglyAdmissiblePattern([1,1,-1]);
true
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="I,T" Name="AsIdealOfNumericalSemigroup"></Func>
  <Description>

    <A>I</A> is an ideal of a numerical semigroup <M>S</M>, and <A>T</A> is a numerical semigroup. Detects if <A>I</A> is an ideal of <A>T</A> and contained in <A>T</A> (integral ideal), and if so, returns <A>I</A> as an ideal of <A>T</A>. It returns <C>fail</C> if <A>I</A> is an ideal of some semigroup but not an integral ideal of <A>t</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> t:=NumericalSemigroup(10,11,14);;
gap> AsIdealOfNumericalSemigroup(10+s,t);
fail
gap> AsIdealOfNumericalSemigroup(100+s,t);
<Ideal of numerical semigroup>
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,C" Name="BoundForConductorOfImageOfPattern"></Func>
  <Description>

     <A>p</A> is the list of integers that are the coefficients of an admissible pattern. <A>C</A> is a positive integer.

     Calculates an upper bound of the smallest element <M>K</M> in <M>p(I)</M> such that all integers larger than <M>K</M> are contained in <M>p(I)</M>, where <M>I</M> is an ideal of a
numerical semigroup. Instead of taking <M>I</M> as parameter, the function takes <M>C</M>, which is assumed to be the conductor of <M>I</M>.
    <Example><![CDATA[
gap> BoundForConductorOfImageOfPattern([1,1,-1],10);
10
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,I" Name="ApplyPatternToIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> is an ideal of a numerical semigroup.<P/>

    Calculates <M>p(I)</M>. Outputs <M>p(I)</M>, represented as <C>[d,p(I)/d]</C>, where <C>d</C > is the gcd of the coefficients of <A>p</A>. All elements of <M>p(I)</M> are divisible by <M>d</M>, and <M>p(I)/d</M> is an ideal of some numerical semigroup. It is returned as the maximal ideal of the numerical semigroup <M>p(I)/d \cup \{0\}</M>. The parent numerical semigroup can later be changed with the function <C>AsIdealOfNumericalSemigroup</C>.


     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=10+s;;
gap> ApplyPatternToIdeal([1,1,-1],i);
[ 1, <Ideal of numerical semigroup> ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,S" Name="ApplyPatternToNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> is  a numerical semigroup.<P/>

    Outputs <C>ApplyPatternToIdeal(p,0+S)</C>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> ApplyPatternToNumericalSemigroup([1,1,-1],s);
[ 1, <Ideal of numerical semigroup> ]
gap> SmallElements(last[2]);
[ 0, 3, 5 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,I,J" Name="IsAdmittedPatternByIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> and <A>J</A> are ideals of certain numerical semigroups.<P/>


    Tests whether or not <M>p(I)</M> is contained in <A>J</A>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=[3,5]+s;;
gap> IsAdmittedPatternByIdeal([1,1,-1],i,i);
false
gap> IsAdmittedPatternByIdeal([1,1,-1],i,0+s);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,S,T" Name="IsAdmittedPatternByNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> and <A>T</A> are numerical semigroups.<P/>


    Tests whether or not <M>p(S)</M> is contained in <A>T</A>.

     <Example><![CDATA[
gap> IsAdmittedPatternByNumericalSemigroup([1,1,-1],s,s);
true
gap> IsArfNumericalSemigroup(s);
true
]]></Example>
  </Description>
</ManSection>



</Section>

<Section><Heading>Functions implemented by I. Ojeda and C. J. Moreno Ávila</Heading>

Ignacio and Carlos Jesús implemented the algorithms given in <Cite Key="Roune"></Cite> and <Cite Key="MC-O-T"></Cite> for the calculation of the Frobenius number and Apéry set of a numerical semigroup using Gröbner basis calculations. These methods will be used if 4ti2 is loaded (either 4ti2Interface or 4ti2gap). A faster algorithm is employed provided that singular is loaded.
</Section>


<Section><Heading>Functions implemented by G. Zito</Heading>
  Giuseppe gave the algorithms for the current version fucntions <C>ArfNumericalSemigroupsWithFrobeniusNumber</C>, <C>ArfNumericalSemigroupsWithFrobeniusNumberUpTo</C>, <C>ArfNumericalSemigroupsWithGenus</C> and <C>ArfNumericalSemigroupsWithGenusUpTo</C>, <C>ArfCharactersOfArfNumericalSemigroup</C>.

</Section>


<Section><Heading>Functions implemented by A. Herrera-Poyatos</Heading>
  Andrés Herrera-Poyatos gave new implementations of <C>IsSelfReciprocalUnivariatePolynomial</C> and <C>IsKroneckerPolynomial</C>
</Section>
</Appendix>
