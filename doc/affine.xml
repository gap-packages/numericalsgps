<?xml version="1.0" encoding="UTF-8"?>

<Section>
    <Heading>
        Defining affine semigroups
    </Heading>

    The most common way to give an affine semigroup is by any of its systems of generators. As for numerical semigroups, any affine semigroup admits a unique minimal system of generators. A system of generators can be represented as a list of lists of nonnegative integers; all lists in the list having the same length (a matrix actually).

    If <M>G</M> is a subgroup of <M>\mathbb Z^k</M>, then <M>S=G\cap \mathbb N^k</M> is an affine semigroup (these semigroups are called <E>full affine semigroups</E>). As <M>G</M> can be represented by its defining equations (homogeneous and some of them possibly in congruences), we can represent <M>S</M> by the defining equations of <M>G</M>; indeed <M>S</M> is just the set of nonnegative solutions of this system of equations. We can represent the equations as a list of lists of integers, all with the same length. Every list is a row of the matrix of coefficients of the system of equations. For the equations in congruences, if we arrange them so that they are the first ones in the list, we provide the corresponding moduli in a list. So for instance, the equations <M>x+y\equiv 0\bmod 2,\ x-2y=0</M> will be represented as [[1,1],[1,-2]] and the moduli [2].
    <P/>

As happens with numerical semigroups, there are different ways to specify an affine semigroup <M>S</M>, namely, by means of a system of generators, a system of homogeneous linear Diophantine equations or a system of homogeneous linear Diophantine inequalities, just to mention some.
In this section we describe functions that may be used
to specify, in one of these ways, an affine semigroup  in &GAP;.


                <ManSection>
                <Func Name="AffineSemigroup" Arg="[String,] List" Label="by generators"/>
                    <Func Name="AffineSemigroupByGenerators" Arg="List"/>
                    <Description>
		      <C>List</C> is a list of n-tuples of nonnegative integers, if the semigroup to be created is n-dimensional. The n-tuples may be given as a list or by a sequence of individual elements. The output is the affine semigroup spanned by <C>List</C>.
		      <P/>
		      <C>String</C> does not need to be present. When it is present, it must be <C>"generators"</C> and <C>List</C> must be a list, not a sequence of individual elements.
			<Example><![CDATA[
gap> s1 := AffineSemigroup([1,3],[7,2],[1,5]);
<Affine semigroup in 2 dimensional space, with 3 generators>
gap> s2 := AffineSemigroup([[1,3],[7,2],[1,5]]);;
gap> s3 := AffineSemigroupByGenerators([1,3],[7,2],[1,5]);;
gap> s4 := AffineSemigroupByGenerators([[1,3],[7,2],[1,5]]);;
gap> s5 := AffineSemigroup("generators",[[1,3],[7,2],[1,5]]);;
gap> Length(Set([s1,s2,s3,s4,s5]));
1
]]></Example>
  </Description>
</ManSection>

<ManSection>
                    <Func Name="AffineSemigroupByEquations" Arg="List"/>
                    <Func Name="AffineSemigroup" Arg="String, List" Label="by equations"/>
                    <Description>
		      <C>List</C> is a list with two components. The first represents a matrix with integer coefficients, say <M>A=(a_{ij})</M>, and so it is a list of lists of integers all with the same length. The second component is a list of positive integers, say <M>d=(d_i)</M>, which may be empty. The list <M>d</M> must be of length less than or equal to the length of <M>A</M> (number of rows of <M>A</M>).
          <P/>
          The output is the full semigroup of nonnegative integer solutions to the system of homogeneous equations
          <Br/>
<M>a_{11}x_1+\cdots+a_{1n}x_n\equiv 0\bmod d_1, </M><Br/>
<M>\cdots </M><Br/>
<M>a_{k1}x_1+\cdots+a_{kn}x_n\equiv 0\bmod d_k, </M><Br/>
<M>a_{k+1\, 1}x_1+\cdots +a_{k+1\, n}=0, </M><Br/>
<M>\cdots </M><Br/>
<M>a_{m1}x_1+\cdots+a_{mn}x_n=0. </M><Br/>
<!--	        <Math>
          \begin{matrix}
          \quad \\
          a_{11}x_1+\cdots+a_{1n}x_n\equiv 0\bmod d_1,\\
          \cdots \\
          a_{k1}x_1+\cdots+a_{kn}x_n\equiv 0\bmod d_k,\\
          a_{k+1\, 1}x_1+\cdots +a_{k+1\, n}=0,\\
          \cdots\\
          a_{m1}x_1+\cdots+a_{mn}x_n=0.
          \end{matrix}
        </Math> -->
          <P/>
          If <M>d</M> is empty, then there will be no equations in congruences.
          <P/>
          As pointed at the beginning of the section, the equations <M>x+y\equiv 0\bmod 2,\ x-2y=0</M> will be represented as <M>A</M> equal to [[1,1],[1,-2]] and the moduli <M>d</M> equal to [2].
		      <P/>
		      In the second form, <C>String</C> must be <C>"equations"</C>.
			<Example><![CDATA[
gap> s1 := AffineSemigroupByEquations([[[-2,1]],[3]]);
<Affine semigroup>
gap> s2 := AffineSemigroup("equations",[[[1,1]],[3]]);
<Affine semigroup>
gap> s1=s2;
true
]]></Example>
  </Description>
</ManSection>
                <ManSection>
                    <Func Name="AffineSemigroupByInequalities" Arg="List"/>
                    <Func Name="AffineSemigroup" Arg="String, List" Label="by inequalities"/>
                    <Description>
		      <C>List</C> is a list of lists (a matrix) of integers that represents a set of inequalities.
          <P/>
          Returns the (normal) affine semigroup of nonegative integer solutions of the system of inequalities <M>List\times X\ge 0</M>.
		      <P/>
		      In the second form, <C>String</C> must be <C>"inequalities"</C>.
			<Example><![CDATA[
gap> a1:=AffineSemigroupByInequalities([[2,-1],[-1,3]]);
<Affine semigroup>
gap> a2:=AffineSemigroup("inequalities",[[2,-1],[-1,3]]);
<Affine semigroup>
gap> a1=a2;
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="Generators" Arg="S" Label="for affine semigroup"/>
  <Func Name="GeneratorsOfAffineSemigroup" Arg="S"/>
  <Description>
    <A>S</A> is an affine semigroup, the output is a system of generators.
    <P/>
    <Example><![CDATA[
gap> a:=AffineSemigroup([[1,0],[0,1],[1,1]]);
<Affine semigroup in 2 dimensional space, with 3 generators>
gap> Generators(a);
[ [ 0, 1 ], [ 1, 0 ], [ 1, 1 ] ]
]]></Example>

  </Description>
</ManSection>

<ManSection>
  <Func Name="MinimalGenerators" Arg="S" Label="for affine semigroup"/>
  <Func Name="MinimalGeneratingSystem" Arg="S" Label="for affine semigroup"/>
  <Description>
    <A>S</A> is an affine semigroup, the output is its system of minimal generators.
    <P/>
    <Example><![CDATA[
gap> a:=AffineSemigroup([[1,0],[0,1],[1,1]]);
<Affine semigroup in 2 dimensional space, with 3 generators>
  gap> MinimalGenerators(a);
  [ [ 0, 1 ], [ 1, 0 ] ]
  ]]></Example>

  </Description>
</ManSection>



<ManSection>
  <Func Name="AsAffineSemigroup" Arg="S"/>
  <Description>
    <A>S</A> is a numerical semigroup, the output is <A>S</A> regarded as an affine semigroup.
    <P/>
    <Example><![CDATA[
gap> s:=NumericalSemigroup(1310,1411,1546,1601);
<Numerical semigroup with 4 generators>
gap> MinimalPresentationOfNumericalSemigroup(s);;time;
2960
gap> a:=AsAffineSemigroup(s);
<Affine semigroup in 1 dimensional space, with 4 generators>
gap> GeneratorsOfAffineSemigroup(a);
[ [ 1310 ], [ 1411 ], [ 1546 ], [ 1601 ] ]
gap> MinimalPresentationOfAffineSemigroup(a);;time;
237972
]]></Example>

If we use the package <C>SingularInterface</C>, the speed up is considerable.

    <Example><![CDATA[
gap> NumSgpsUseSingularInterface();
...
gap> MinimalPresentationOfAffineSemigroup(a);;time;
32
]]></Example>


  </Description>
</ManSection>


<ManSection>
  <Attr Name="IsAffineSemigroup" Arg="AS"/>
  <Attr Name="IsAffineSemigroupByGenerators" Arg="AS"/>
  <Attr Name="IsAffineSemigroupByEquations" Arg="AS"/>
  <Attr Name="IsAffineSemigroupByInequalities" Arg="AS"/>
  <Description>
    <A>AS</A> is an affine semigroup and these attributes are available
    (their names should be self explanatory). They reflect what is currently known about the semigroup.
    <Example><![CDATA[
gap> a1:=AffineSemigroup([[3,0],[2,1],[1,2],[0,3]]);
<Affine semigroup in 2 dimensional space, with 4 generators>
gap> IsAffineSemigroupByEquations(a1);
false
gap> IsAffineSemigroupByGenerators(a1);
true
gap> ns := NumericalSemigroup(3,5);
<Numerical semigroup with 2 generators>
gap> IsAffineSemigroup(ns);
false
gap> as := AsAffineSemigroup(ns);
<Affine semigroup in 1 dimensional space, with 2 generators>
gap> IsAffineSemigroup(as);
true
]]></Example>
  </Description>
</ManSection>




<ManSection>
  <Func Arg="v, a" Name="BelongsToAffineSemigroup"></Func>
                    <Oper Name="\in" Arg="v, a" Label="membership test in affine semigroup"/>
  <Description>
    <A>v</A> is a list of nonnegative integers and <A>a</A> an affine semigroup.
    Returns true if the vector is in the semigroup, and false otherwise.

    <P/>
    If the semigroup is full and its equations are known (either because the semigroup was defined by equations, or because the user has called <C>IsFullAffineSemgiroup(a)</C> and the output was true), then membership is performed by evaluating <A>v</A> in the equations. The same holds for normal semigroups and its defining inequalities.
                        <P/>
                        <A> v in a</A> can be used for short.
    <Example><![CDATA[
gap> a:=AffineSemigroup([[2,0],[0,2],[1,1]]);;
gap> BelongsToAffineSemigroup([5,5],a);
true
gap> BelongsToAffineSemigroup([1,2],a);
false
gap> [5,5] in a;
true
gap> [1,2] in a;
false
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Prop Arg="S" Name="IsFull"></Prop>
  <Prop Arg="S" Name="IsFullAffineSemigroup"></Prop>
  <Description>
    <A>S</A> is an affine semigroup.<P/>

    Returns true if the semigroup is full, false otherwise. The semigroup is full if whenever <M>a,b\in S</M> and <M>b-a\in \mathbb N^k</M>, then <M>a-b\in S</M>, where <M>k</M> is the dimension of <M>S</M>.
    <P/>
    If the semigroup is full, then its equations are stored in the semigroup for further use.

<Example><![CDATA[
gap> a:=AffineSemigroup("equations",[[[1,1,1],[0,0,2]],[2,2]]);;
gap> IsFull(a);
true
gap> IsFullAffineSemigroup(a);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>

  <Oper Arg="ls, m" Name="HilbertBasisOfSystemOfHomogeneousEquations"></Oper>
  <Description>
    <A>ls</A> is a list of lists of integers and <A>m</A> a list of integers. The elements of <A>ls</A> represent the rows of a matrix <M>A</M>.
    The output is a minimal generating system (Hilbert basis) of the set of nonnegative integer solutions of the system <M>Ax=0</M> where the <M>k</M> first equations are in the congruences modulo <A>m[i]</A>, with <M>k</M> the length of <A>m</A>. <P/>
    If the package <C>NormalizInterface</C> has not been loaded, then Contejean-Devie algorithm is used <Cite Key="MR1283022"></Cite> instead (if this is the case, congruences are treated as in <Cite Key="R-GS"></Cite>).

    <Example><![CDATA[
gap> HilbertBasisOfSystemOfHomogeneousEquations([[1,0,1],[0,1,-1]],[2]);
[ [ 0, 2, 2 ], [ 1, 1, 1 ], [ 2, 0, 0 ] ]
]]></Example>
  </Description>
</ManSection>

If <M>C</M> is a pointed cone (a cone in <M>\mathbb Q^k</M> not containing lines and <M>0\in C</M>), then <M>S=C\cap \mathbb N^k</M> is an affine semigroup (known as normal affine semigroup). So another way to give an affine semigroup is by a set of homogeneous inequalities, and we can represent these inequalities by its coefficients. If we put them in a matrix <M>S</M> can be defined as the set of nonnegative integer solutions to <M>Ax \ge 0</M>.

<ManSection>
  <Oper Arg="ls" Name="HilbertBasisOfSystemOfHomogeneousInequalities"></Oper>
  <Description>
    <A>ls</A> is a list of lists of integers. The elements of <A>ls</A> represent the rows of a matrix <M>A</M>.
            The output is a minimal generating system (Hilbert basis) of the set of nonnegative integer solutions to  <M>Ax\ge 0</M>.
 <P/>
    If the package <C>NormalizInterface</C> has not been loaded, then Contejean-Devie algorithm is used <Cite Key="MR1283022"></Cite> instead (the use of slack variables is described in <Cite Key="R-GS-GG-B"></Cite>).

            <Example><![CDATA[
gap> HilbertBasisOfSystemOfHomogeneousInequalities([[2,-3],[0,1]]);
[ [ 1, 0 ], [ 2, 1 ], [ 3, 2 ] ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="M" Name="EquationsOfGroupGeneratedBy"></Func>
  <Description>
    <A>M</A> is a matrix of integers. The output is a pair <M>[A,m]</M> that represents the set of defining equations of the group spanned by the rows of <A>M</A>: <M>Ax=0\in \mathbb Z_{n_1}\times \cdots \times \mathbb Z_{n_t}\times \mathbb Z^k</M>, with <M>m=[n_1,\ldots,n_t]</M>.

    <Example><![CDATA[
gap> EquationsOfGroupGeneratedBy([[1,2,0],[2,-2,2]]);
[ [ [ 0, 0, -1 ], [ -2, 1, 3 ] ], [ 2 ] ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="A, m" Name="BasisOfGroupGivenByEquations"></Func>
  <Description>
    <A>A</A> is a matrix of integers and <A>m</A> is a list of positive integers. The output is a basis for the group with defining equations  <M>Ax=0\in \mathbb Z_{n_1}\times \cdots \times \mathbb Z_{n_t}\times \mathbb Z^k</M>, with <M>m=[n_1,\ldots,n_t]</M>.

    <Example><![CDATA[
gap> BasisOfGroupGivenByEquations([[0,0,1],[2,-1,-3]],[2]);
[ [ -1, -2, 0 ], [ -2, 2, -2 ] ]
]]></Example>
  </Description>
</ManSection>

</Section>


<Section>
  <Heading>
    Gluings of affine semigroups
  </Heading>

  Let <M>S_1</M> and <M>S_2</M> be two affine semigroups with the same dimension generated by <M>A_1</M> and <M>A_2</M>, respectively. We say that the affine semigroup <M>S</M> generated by the union of <M>A_1</M> and <M>A_2</M> is a gluing of <M>S_1</M> and <M>S_2</M> if <M>G(S_1)\cap G(S_2)=d\mathbb Z</M> (<M>G(\cdot)</M> stands for group spanned by) for some <M>d\in S_1\cap S_2</M>.
  <P/> The algorithm used is explained in <Cite Key="MR1678508"></Cite>.

<ManSection>
  <Func Arg="a1, a2" Name="GluingOfAffineSemigroups"></Func>
  <Description>
    <A>a1, a2</A> are affine semigroups. Determines if they can be glued, and if so, returns the gluing. Otherwise it returns fail.

    <Example><![CDATA[
gap> a1:=AffineSemigroup([[2,0],[0,2]]);
<Affine semigroup in 2 dimensional space, with 2 generators>
gap> a2:=AffineSemigroup([[1,1]]);
<Affine semigroup in 2 dimensional space, with 1 generators>
gap> GluingOfAffineSemigroups(a1,a2);
<Affine semigroup in 2 dimensional space, with 3 generators>
gap> Generators(last);
[ [ 0, 2 ], [ 1, 1 ], [ 2, 0 ] ]
]]></Example>
  </Description>
</ManSection>


</Section>

<Section>
  <Heading>
    Presentations of affine semigroups
  </Heading>

  A <E>minimal presentation</E> of an affine semigroup is defined analogously as for numerical semigroups (See Chapter <Ref Chap="ch:min-pres"/>). We warn the user to take into account that generators are stored in a set, and thus might be arranged in a different way to the initial input.

  <ManSection>
    <Oper Arg="M" Name="GeneratorsOfKernelCongruence"></Oper>
    <Description>
      <A>M</A> is matrix with nonnegative integer coefficients.
      The output is a system of generators of the congruence <M>\{(x,y)\mid xM=yM\}</M>.
  <P/>
  The main difference with <Ref Func="MinimalPresentationOfAffineSemigroup"/> is that the matrix <A>M</A> can have repeated columns and these are not treated as a set.
      <Example><![CDATA[
gap> M := [[2,0],[0,2],[1,1]];
[ [ 2, 0 ], [ 0, 2 ], [ 1, 1 ] ]
gap> GeneratorsOfKernelCongruence(M);
[ [ [ 0, 0, 2 ], [ 1, 1, 0 ] ] ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Arg="M, Ord" Name="CanonicalBasisOfKernelCongruence"></Oper>
    <Description>
      <A>M</A> is matrix with nonnegative integer coefficients, <A>Ord</A> a term ordering.
      The output is a canonical basis of the congruence <M>\{(x,y)\mid xM=yM\}</M> (see <Cite Key="RGS99"></Cite>). This corresponds with the exponents of the Gröbner basis of the kernel ideal of the morphism <M>x_i\mapsto Y^{m_i}</M>, with <M>m_i</M> the <M>i</M>th row of <M>M</M>.
  <P/>
    Accepted term orderings are lexicographic (<C>MonomialLexOrdering()</C>), graded lexicographic (<A>MonomialGrlexOrdering()</A>) and reversed graded lexicographic (<A>MonomialGrevlexOrdering()</A>).
    <Example><![CDATA[
gap> M:=[[3],[5],[7]];;
gap> CanonicalBasisOfKernelCongruence(M,MonomialLexOrdering());
[ [ [ 0, 7, 0 ], [ 0, 0, 5 ] ], [ [ 1, 0, 1 ], [ 0, 2, 0 ] ],
  [ [ 1, 5, 0 ], [ 0, 0, 4 ] ], [ [ 2, 3, 0 ], [ 0, 0, 3 ] ],
  [ [ 3, 1, 0 ], [ 0, 0, 2 ] ], [ [ 4, 0, 0 ], [ 0, 1, 1 ] ] ]
gap> CanonicalBasisOfKernelCongruence(M,MonomialGrlexOrdering());
[ [ [ 0, 7, 0 ], [ 0, 0, 5 ] ], [ [ 1, 0, 1 ], [ 0, 2, 0 ] ],
  [ [ 1, 5, 0 ], [ 0, 0, 4 ] ], [ [ 2, 3, 0 ], [ 0, 0, 3 ] ],
  [ [ 3, 1, 0 ], [ 0, 0, 2 ] ], [ [ 4, 0, 0 ], [ 0, 1, 1 ] ] ]
gap> CanonicalBasisOfKernelCongruence(M,MonomialGrevlexOrdering());
[ [ [ 0, 2, 0 ], [ 1, 0, 1 ] ], [ [ 3, 1, 0 ], [ 0, 0, 2 ] ],
  [ [ 4, 0, 0 ], [ 0, 1, 1 ] ] ]
]]></Example>

    </Description>
  </ManSection>

  <ManSection>
    <Oper Arg="M" Name="GraverBasis"></Oper>
    <Description>
      <A>M</A> is matrix with  integer coefficients.
      The output is a Graver basis for <A>M</A>.
    <Example><![CDATA[
gap> gr:=GraverBasis([[3,5,7]]);
[ [ -7, 0, 3 ], [ -5, 3, 0 ], [ -4, 1, 1 ], [ -3, -1, 2 ], [ -2, -3, 3 ],
  [ -1, -5, 4 ], [ -1, 2, -1 ], [ 0, -7, 5 ], [ 0, 7, -5 ], [ 1, -2, 1 ],
  [ 1, 5, -4 ], [ 2, 3, -3 ], [ 3, 1, -2 ], [ 4, -1, -1 ], [ 5, -3, 0 ],
  [ 7, 0, -3 ] ]
]]></Example>

    </Description>
  </ManSection>


  <ManSection>
    <Oper Arg="a" Name="MinimalPresentation" Label="for affine semigroup"></Oper>
        <Oper Arg="a" Name="MinimalPresentationOfAffineSemigroup"></Oper>
    <Description>
      <A>a</A> is an affine semigroup.
      The output is a minimal presentation for <A>a</A>.
  <P/>
  There are four methods implemented for this function, depending on the packages loaded. All of them use elimination, and Herzog's correspondence, computing the kernel of a ring homomorphism (<Cite Key="MR0269762"></Cite>). The fastest procedure is achieved when <C>SingularInterface</C> is loaded, followed by <C>Singular</C>. The procedure that does not use external packages uses internal GAP Gröbner basis computations and thus it is slower. Also in this case, from the Gröbner basis, a minimal set of generating binomials must be refined, and for this Rclasses are used (if <C>NormalizInterface</C> is loaded, then the factorizations are faster). The <C>4ti2</C> implementation uses <C>4ti2</C> internal Gröbner bases and factorizations are done via <C>zsolve</C>.

      <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> MinimalPresentation(a);
[ [ [ 0, 2, 0 ], [ 1, 0, 1 ] ] ]
gap> MinimalPresentationOfAffineSemigroup(a);
[ [ [ 0, 2, 0 ], [ 1, 0, 1 ] ] ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Arg="a" Name="BettiElements" Label="of affine semigroup"></Oper>
        <Oper Arg="a" Name="BettiElementsOfAffineSemigroup"></Oper>
    <Description>
      <A>a</A> is an affine semigroup.
      The output is the set of Betti elements of <A>a</A> (defined as for numerical semigroups).
<P/> This function relies on the computation of a minimal presentation.
      <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> BettiElements(a);
[ [ 2, 2 ] ]
gap> BettiElementsOfAffineSemigroup(a);
[ [ 2, 2 ] ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Arg="v, a" Name="ShadedSetOfElementInAffineSemigroup"></Func>
    <Description>
      <A>a</A> is an affine semigroup and <A>v</A> is an element in <A>a</A>.

      This is a translation to affine semigroups of <C>ShadedSetOfElementInNumericalSemigroup</C> (<Ref Chap="shadedset"/>).

    </Description>
  </ManSection>


  <ManSection>
    <Prop Arg="a" Name="IsGeneric" Label="for affine semigroups"></Prop>
    <Prop Arg="a" Name="IsGenericAffineSemigroup"></Prop>
    <Description>
      <A>a</A> is an affine semigroup.
      <P/>
      The same as <C>IsGenericNumericalSemigroup</C> (<Ref Chap="Generic"/>) but for affine semigroups. 
      <P/>
      This property implies <Ref Func="IsUniquelyPresentedAffineSemigroup"/>. 
    </Description>
  </ManSection>

  <ManSection>
  <Prop Arg="a" Name="IsUniquelyPresented" Label="for affine semigroups"></Prop>
    <Prop Arg="a" Name="IsUniquelyPresentedAffineSemigroup"></Prop>
    <Description>
      <A>a</A> is an affine semigroup.
      <P/>
      The same as the homonym function for numerical semigroups (<Ref Chap="UniqPre"/>), but for affine semigroups.
    </Description>
  </ManSection>


  <ManSection>
    <Oper Arg="a" Name="DegreesOfPrimitiveElementsOfAffineSemigroup"></Oper>
    <Description>
      <A>a</A> is an affine semigroup.
      The output is the set of primitive elements of <A>a</A> (defined as for numerical semigroups).
<P/>This function has three implementations (methods), one using Graver basis via the Lawrence lifting of <A>a</A> and the other (much faster) using  <C>NormalizInterface</C>. Also a <C>4ti2</C> version using its Graver basis computation is provided.
      <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> DegreesOfPrimitiveElementsOfAffineSemigroup(a);
[ [ 0, 2 ], [ 1, 1 ], [ 2, 0 ], [ 2, 2 ] ]
]]></Example>
    </Description>
  </ManSection>

</Section>


<Section>
  <Heading>
    Factorizations in affine semigroups
  </Heading>

  The invariants presented here are defined as for numerical semigroups (Chapter <Ref Chap="ch:factorizations"/>).

  <P/>As with presentations, the user should take into account that generators are stored in a set, and thus might be arranged in a different way to the initial input.


  <ManSection>
    <Oper Arg="v, ls" Name="FactorizationsVectorWRTList"></Oper>
    <Description>
      <A>v</A> is a list of nonnegative integers and <A>ls</A> is a list of lists of nonnegative integers.
      The output is set of factorizations of <A>v</A> in terms of the elements of <A>ls</A>.
  <P/>
  If no extra package is loaded, then factorizations are computed recursively; and thus slowly. If <C>NormalizInterface</C> is loaded, then a system of equations is solved with Normaliz, and the performance is much better. If <C>4ti2Interface</C> is loaded instead, then factorizations are calculated using <C>zsolve</C> command of <C>4ti2</C>.

      <Example><![CDATA[
gap> FactorizationsVectorWRTList([5,5],[[2,0],[0,2],[1,1]]);
[ [ 2, 2, 1 ], [ 1, 1, 3 ], [ 0, 0, 5 ] ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Arg="v, a" Name="Factorizations" Label="for an element in an affine semigroup"></Oper>
    <Oper Arg="a, v" Name="Factorizations"></Oper>
    <Description>
      <A>v</A> is a list of nonnegative integers and <A>a</A> is an affine semigroup. 
      The output is set of factorizations of <A>v</A> in terms of the minimal generators of of <A>a</A>.
  <P/>
      <Example><![CDATA[
gap> a:=AffineSemigroup([[2,0],[0,2],[1,1]]);
<Affine semigroup in 2 dimensional space, with 3 generators>
gap> Factorizations([5,5],a);
[ [ 2, 1, 2 ], [ 1, 3, 1 ], [ 0, 5, 0 ] ]
gap> Factorizations(a,[5,5]);
[ [ 2, 1, 2 ], [ 1, 3, 1 ], [ 0, 5, 0 ] ]
gap> MinimalGenerators(a);
[ [ 0, 2 ], [ 1, 1 ], [ 2, 0 ] ]
]]></Example>
    </Description>
  </ManSection>


<ManSection>
   <Oper Arg="n, a" Name="Elasticity" Label="for the factorizations of an element in an affine semigroup"></Oper>
  <Oper Arg="a, n" Name="Elasticity" Label="for the factorizations in an affine semigroup of one of its elements"></Oper>
 <Func Arg="n, a" Name="ElasticityOfFactorizationsElementWRTAffineSemigroup"></Func>
  <Description>
      <A>a</A> is an affine semigroup and <A>n</A> an element of <A>a</A>.
      The output is the maximum length divided by the minimum length
      of the factorizations of <A>n</A> in terms of the minimal
      generating set of <A>a</A>.

      <Example><![CDATA[
gap> a:=AffineSemigroup([[2,0],[0,2],[1,1]]);;
gap> Elasticity([5,5],a);
1
gap> Elasticity(a,[5,5]);
1
gap> ElasticityOfFactorizationsElementWRTAffineSemigroup([5,5],a);
1
]]></Example>
         </Description>
</ManSection>


<ManSection>
  <Oper Arg="a" Name="Elasticity" Label="for affine semigroups"></Oper>
  <Oper Arg="a" Name="ElasticityOfAffineSemigroup"></Oper>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the elasticity of <A>a</A> (defined as for numerical semigroups).
	    <P/> The procedure used is based on <Cite Key="PH"></Cite>, where it is shown that the elasticity can be computed by using circuits. The set of circuits is calculated using <Cite Key="MR1394747"></Cite>.

            <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> Elasticity(a);
1
gap> ElasticityOfAffineSemigroup(a);
1
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Arg="a" Name="DeltaSet" Label="for an affine semigroup"></Oper>
  <Func Arg="a" Name="DeltaSetOfAffineSemigroup"></Func>

  <Description>
    <A>a</A> is an affine semigroup.
            The output is the Delta set of <A>a</A> (defined as for numerical semigroups). The the procedure used is explained in <Cite Key="GSONW"></Cite>.
<Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> DeltaSet(a);
[  ]
gap> s:=NumericalSemigroup(10,13,15,47);;
gap> a:=AsAffineSemigroup(s);;
gap> DeltaSetOfAffineSemigroup(a);
[ 1, 2, 3, 5 ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Oper Arg="a" Name="CatenaryDegree" Label="for affine semigroups"/>
  <Func Arg="a" Name="CatenaryDegreeOfAffineSemigroup"></Func>

  <Description>
    <A>a</A> is an affine semigroup.
            The output is the catenary degree of <A>a</A> (defined as for numerical semigroups).
<Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> CatenaryDegree(a);
2
gap> CatenaryDegreeOfAffineSemigroup(a);
2
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="a" Name="EqualCatenaryDegreeOfAffineSemigroup"></Func>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the equal catenary degree of <A>a</A> (defined as for numerical semigroups).
<P/>This function relies on the results presented in <Cite Key="GSOSN"></Cite>.
  </Description>
</ManSection>

<ManSection>
  <Func Arg="a" Name="HomogeneousCatenaryDegreeOfAffineSemigroup"></Func>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the homogeneous catenary degree of <A>a</A> (defined as for numerical semigroups).
<P/>This function is based on <Cite Key="GSOSN"></Cite>.
  </Description>
</ManSection>


<ManSection>
  <Func Arg="a" Name="MonotoneCatenaryDegreeOfAffineSemigroup"></Func>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the monotone catenary degree of <A>a</A> (defined as for numerical semigroups), computed as explained in  <Cite Key="PH"></Cite>.
            <Example><![CDATA[
gap> a:=AffineSemigroup("inequalities",[[2,-1],[-1,3]]);
<Affine semigroup>
gap> GeneratorsOfAffineSemigroup(a);
[ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 3, 1 ] ]
gap> CatenaryDegreeOfAffineSemigroup(a);
3
gap> EqualCatenaryDegreeOfAffineSemigroup(a);
2
gap> HomogeneousCatenaryDegreeOfAffineSemigroup(a);
3
gap> MonotoneCatenaryDegreeOfAffineSemigroup(a);
3
]]></Example>
  </Description>
</ManSection>



<ManSection>
  <Oper Arg="a" Name="TameDegree" Label="for affine semigroups"></Oper>
  <Oper Arg="a" Name="TameDegreeOfAffineSemigroup"></Oper>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the tame degree of <A>a</A> (defined as for numerical semigroups). If <A>a</A> is given by equations (or its equations are known), then the procedure explained in <Cite Key="GSONW"></Cite> is used.

            <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> TameDegree(a);
2
gap> TameDegreeOfAffineSemigroup(a);
2
]]></Example>
  </Description>
</ManSection>


<ManSection>
 <Oper Arg="v,a" Name="OmegaPrimality" Label="for an element in an affine semigroup"></Oper>
  <Oper Arg="a,v" Name="OmegaPrimality" Label="for an affine semigroup and one of its elements"></Oper>
 <Oper Arg="v,a" Name="OmegaPrimalityOfElementInAffineSemigroup"></Oper>
    <Description>
    <A>v</A> is a list of nonnegative integers and <A>a</A> is an affine semigroup.
            The output is the omega primality of <A>a</A> (defined as for numerical semigroups). Returns 0 if the element is not in the semigroup.
<P/> The implementation of this procedure is performed as explained in <Cite Key="B-GS-G"></Cite> (also, if the semigroup has defining equations, then it takes advantage of this fact as explained in this reference).

            <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> OmegaPrimality(a,[5,5]);
6
gap> OmegaPrimality([5,5],a);
6
gap> OmegaPrimalityOfElementInAffineSemigroup([5,5],a);
6
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Oper Arg="a" Name="OmegaPrimality" Label="for an affine semigroup"></Oper>
  <Func Arg="a" Name="OmegaPrimalityOfAffineSemigroup"></Func>
  <Description>
    <A>a</A> is an affine semigroup.
            The output is the omega primality of <A>a</A> (defined as for numerical semigroups).

            <Example><![CDATA[
gap> a:=AffineSemigroup([2,0],[0,2],[1,1]);;
gap> OmegaPrimality(a);
2
gap> OmegaPrimalityOfAffineSemigroup(a);
2
]]></Example>
  </Description>
</ManSection>



</Section>
