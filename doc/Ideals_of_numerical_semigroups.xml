<?xml version="1.0" encoding="UTF-8"?>

        Let <M>S</M> be a numerical semigroup. A set <M>I</M> of integers is an <E>ideal relative</E>
        to a numerical semigroup <M>S</M> provided that <M>I+S\subseteq I</M> and that there
        exists <M>d\in S</M> such that <M>d+I\subseteq S</M>.
        <P/>
        If <M>\{i_1,\ldots,i_k\}</M> is a subset of <M>{\mathbb Z}</M>, then the set
        <M>I=\{i_1,\ldots,i_k\}+S=\bigcup_{n=1}^k i_n+S</M> is an ideal relative to <M>S</M>,
        and <M>\{i_1,\ldots, i_k\}</M> is a system of generators of <M>I</M>. A system of generators 
        <M>M</M> is minimal if no proper subset of <M>M</M> generates the same ideal.
        Usually, ideals are specified by means of its generators and the ambient numerical
        semigroup to which they are ideals (for more information see for instance
        <Cite Key="BDF97"></Cite>).

<Section>
                <Heading>
                    Definitions and basic operations
                </Heading>


                <ManSection>
                    <Func Arg="l,S" Name="IdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>S</A> is a numerical semigroup and <A>l</A> a list of integers.
                        <P/>

                        The output is the ideal of <A>S</A> generated by <A>l</A>

                        <P/>
                        There are several shortcuts for this function, as shown in the example.
                        <Example><![CDATA[
gap> IdealOfNumericalSemigroup([3,5],NumericalSemigroup(9,11));
<Ideal of numerical semigroup>
gap> [3,5]+NumericalSemigroup(9,11);
<Ideal of numerical semigroup>
gap> last=last2;
true
gap> 3+NumericalSemigroup(5,9);
<Ideal of numerical semigroup>
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="Obj" Name="IsIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Tests if the object <A>Obj</A> is an ideal of a
                        numerical semigroup.

                        <Example><![CDATA[
gap> I:=[1..7]+NumericalSemigroup(7,19);;
gap> IsIdealOfNumericalSemigroup(I);
true
gap> IsIdealOfNumericalSemigroup(2);
false
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I" Name="MinimalGeneratingSystemOfIdealOfNumericalSemigroup"></Func>
<Func Arg="I" Name="MinimalGeneratingSystem"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        <P/>

                        The output is the minimal system of generators of <A>I</A>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I);
[ 3 ]
gap> MinimalGeneratingSystem(I);                           
[ 3 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="I" Name="GeneratorsOfIdealOfNumericalSemigroup"></Func>
                    <Func Arg="I" Name="GeneratorsOfIdealOfNumericalSemigroupNC"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        <P/>

                        The output of <C>GeneratorsOfIdealOfNumericalSemigroup</C> is a system of generators of the ideal. If the minimal system of generators
                        is known, then it is used as output.
                        <C>GeneratorsOfIdealOfNumericalSemigroupNC</C> always returns the set of generators stored in <A>I!.generators</A>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> GeneratorsOfIdealOfNumericalSemigroup(I);
[ 3, 5, 9 ]
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I);
[ 3 ]
gap> GeneratorsOfIdealOfNumericalSemigroup(I);
[ 3 ]
gap> GeneratorsOfIdealOfNumericalSemigroupNC(I);
[ 3, 5, 9 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I" Name="AmbientNumericalSemigroupOfIdeal"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, say <M>S</M>.
                        <P/>

                        The output is <M>S</M>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> AmbientNumericalSemigroupOfIdeal(I);
<Modular numerical semigroup satisfying 11x mod 22 <= x >
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="I" Name="SmallElementsOfIdealOfNumericalSemigroup"></Func><Func Arg="I" Name="SmallElements"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        <P/>

                        The output is a list with the elements in <A>I</A> that are less than or equal
                        to the greatest integer not belonging to the ideal plus one.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> SmallElementsOfIdealOfNumericalSemigroup(I);
[ 3, 5, 7, 9, 11, 13 ]
gap> SmallElements(I) = SmallElementsOfIdealOfNumericalSemigroup(I);
true
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> SmallElementsOfIdealOfNumericalSemigroup(J);
[ 2, 4, 6, 8, 10 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="n, I" Name="BelongsToIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is an integer.
                        <P/>

                        The output is true if <A>n</A> belongs to <A>I</A>.

                        <P/>
                        <A> n in I</A> can be used for short.

                        <Example><![CDATA[
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> BelongsToIdealOfNumericalSemigroup(9,J);
false
gap> 9 in J;
false
gap> BelongsToIdealOfNumericalSemigroup(10,J);
true
gap> 10 in J;
true
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="I, J" Name="SumIdealsOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        <P/>

                        The output is the sum of both ideals <M>\{ i+j \ |\  i\in <A>I</A>, j\in <A>J</A>\}</M>.

                        <P/>
                        <A>I + J</A> is a synonym of this function.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> I+J;
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
gap> SumIdealsOfNumericalSemigroup(I,J);
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="n, I" Name="MultipleOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer.
                        <P/>

                        The output is the ideal <M><A>I</A>+\cdots+<A>I</A></M> (<A>n</A> times).

                        <P/>
                        <A> n * I</A> can be used for short.

                        <Example><![CDATA[
gap> I:=[0,1]+NumericalSemigroup(3,5,7);;
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(2*I);
[ 0, 1, 2 ]
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="I, J" Name="SubtractIdealsOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        <P/>

                        The output is the ideal <M>\{ z\in {\mathbb Z}\ |\  z+<A>J</A>\subseteq <A>I</A>\}</M>.

                        <P/>
                        <A>I - J</A> is a synonym of this function.

                        <P/>
                        <M>S-</M><A>J</A> is a synonym of <M>(0+S)-</M><A>J</A>, if <M>S</M> is the ambient semigroup of <A>I</A> and <A>J</A>.

                        The following example appears in <Cite Key="HS04"></Cite>.
                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;;
gap> II:=S-I;;
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I);
[ 0, 1 ]
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(II);
[ 14, 20 ]
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I+II);
[ 14, 15, 20, 21 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I, J" Name="DifferenceOfIdealsOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup. <A>J</A> must be contained in <A>I</A>.
                        <P/>

                        The output is the set <M><A>I</A>\setminus <A>J</A></M>.

                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;
<Ideal of numerical semigroup>
gap> 2*I-2*I;
<Ideal of numerical semigroup>
gap> I-I;
<Ideal of numerical semigroup>
gap> DifferenceOfIdealsOfNumericalSemigroup(last2,last);
[ 26, 27, 37, 38 ]
]]></Example>
                    </Description>
                </ManSection>


				<ManSection>
					<Func Arg="k, I" Name="TranslationOfIdealOfNumericalSemigroup"></Func>
					<Description>
			Given an ideal <A>I</A> of a numerical semigroup S and an integer <A>k</A>
			returns an ideal of the numerical semigroup S generated by
			<M>\{i_1+k,\ldots,i_n+k\}</M> where <M>\{i_1,\ldots,i_n\}</M> is the system of generators of <A>I</A>.
			<P/>
			As a synonym to <C>TranslationOfIdealOfNumericalSemigroup(k, I)</C> the expression
			<C>k + I</C> may be used.

						<Example><![CDATA[
gap> s:=NumericalSemigroup(13,23);;
gap> l:=List([1..6], _ -> Random([8..34]));
[ 22, 29, 34, 25, 10, 12 ]
gap> I:=IdealOfNumericalSemigroup(l, s);;
gap> It:=TranslationOfIdealOfNumericalSemigroup(7,I);
<Ideal of numerical semigroup>
gap> It2:=7+I;
<Ideal of numerical semigroup>
gap> It2=It;
true
]]></Example>
									</Description>
                </ManSection>

<ManSection>
                    <Func Arg="I, J" Name="IntersectionIdealsOfNumericalSemigroup"></Func>
                    <Description>
Given two ideals <A>I</A> and <A>J</A> of a numerical semigroup <A>S</A>
returns the ideal of the numerical semigroup <A>S</A> which is the
intersection of the ideals <A>I</A> and <A>J</A>.

                        <Example><![CDATA[
gap> i:=IdealOfNumericalSemigroup([75,89],s);;
gap> j:=IdealOfNumericalSemigroup([115,289],s);;
gap> IntersectionIdealsOfNumericalSemigroup(i,j);
<Ideal of numerical semigroup>
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
                    <Func Arg="S" Name="MaximalIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the maximal ideal of the numerical semigroup <A>S</A>.

                        <Example><![CDATA[
gap> MaximalIdealOfNumericalSemigroup(NumericalSemigroup(3,7));
<Ideal of numerical semigroup>
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
                    <Func Arg="S" Name="CanonicalIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Computes a canonical ideal of <A>S</A> (<Cite Key="BF06"></Cite>):
                        <M>\{ x \in \mathbb{Z} | g-x \not \in S\} </M>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(4,6,11);;
gap> m:=MaximalIdealOfNumericalSemigroup(s);;
gap> c:=CanonicalIdealOfNumericalSemigroup(s);
<Ideal of numerical semigroup>
gap> (m-c)-c=m;
true
gap> id:=3+s;
<Ideal of numerical semigroup>
gap> (id-c)-c=id;
true
]]></Example>
                    </Description>
                </ManSection>


</Section>

<Section>
                <Heading>
                    Other functions for ideals
                </Heading>

                <ManSection>
                    <Func Arg="n, I" Name="HilbertFunctionOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer. <A>I</A> must be contained in its ambient semigroup.
                        <P/>

                        The output is the cardinality of the set <M><A>n</A><A>I</A>\setminus (<A>n</A>+1)<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[6,9,11]+NumericalSemigroup(6,9,11);;
gap> List([1..7],n->HilbertFunctionOfIdealOfNumericalSemigroup(n,I));
[ 3, 5, 6, 6, 6, 6, 6 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="I" Name="BlowUpIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        <P/>

                        The output is the ideal <M>\bigcup_{n\geq 0} n<A>I</A>-n<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> BlowUpIdealOfNumericalSemigroup(I);;
gap> SmallElementsOfIdealOfNumericalSemigroup(last);
[ 0, 2, 4, 6, 8 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I" Name="ReductionNumberIdealNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        <P/>

                        The output is the least integer
                        such that  <M>n <A>I</A> + i=(n+1)<A>I</A></M>, where <M>i=min(<A>I</A>)</M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> ReductionNumberIdealNumericalSemigroup(I);
2
]]></Example>
                    </Description>
                </ManSection>





<ManSection>
                    <Func Arg="S" Name="BlowUpOfNumericalSemigroup"></Func>
                    <Description>
                        If <A>M</A> is the maximal ideal of the numerical semigroup, then
                        the output is the numerical semigroup
                        <M>\bigcup_{n\geq 0} n<A>M</A>-n<A>M</A></M>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BlowUpOfNumericalSemigroup(s);
<Numerical semigroup with 10 generators>
gap> SmallElementsOfNumericalSemigroup(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
gap> m:=MaximalIdealOfNumericalSemigroup(s);
<Ideal of numerical semigroup>
gap> BlowUpIdealOfNumericalSemigroup(m);
<Ideal of numerical semigroup>
gap> SmallElementsOfIdealOfNumericalSemigroup(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
                    <Func Arg="S" Name="MicroInvariantsOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the microinvariants of the numerical semigroup <A>S</A> defined
                        in <Cite Key="E01"></Cite>. For their computation we have used the formula
                        given in <Cite Key="BF06"></Cite>. The Ap\'ery set of <A>S</A> and its
                        blow up are involved in this computation.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> bu:=BlowUpOfNumericalSemigroup(s);;
gap> ap:=AperyListOfNumericalSemigroupWRTElement(s,30);;
gap> apbu:=AperyListOfNumericalSemigroupWRTElement(bu,30);;
gap> (ap-apbu)/30;
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> MicroInvariantsOfNumericalSemigroup(s)=last;
true
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCM"></Func>
                    <Description>
                        Returns true if the graded ring associated to <M>K[[<A>S</A>]]</M>
                        is Cohen-Macaulay, and false otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="BF06"></Cite>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
false
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,30),
> w->MaximumDegreeOfElementWRTNumericalSemigroup (w,s));
[ 0, 1, 4, 1, 2, 1, 3, 1, 4, 3, 2, 3, 1, 1, 4, 3, 3, 1, 4, 1, 4, 3, 2, 4, 2,
  5, 4, 3, 1, 2 ]
gap> last=last2;
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
true
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 2, 1, 1 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,4),
> w->MaximumDegreeOfElementWRTNumericalSemigroup(w,s));
[ 0, 2, 1, 1 ]
]]></Example>
                    </Description>
                </ManSection>




                <Heading>
                    Monomial Numerical Semigroups
                </Heading>

                <ManSection>
                    <Func Arg="S" Name="IsMonomialNumericalSemigroup"></Func>
                    <Description>
                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Tests whether <A>S</A> a monomial numerical semigroup.
<P/>
                Let <M>R</M> a Noetherian ring such that <M>K \subseteq R \subseteq K[[t]]</M>, <M>K</M> 
                is a field of characteristic zero, the algebraic closure of <M>R</M> is <M>K[[t]]</M>, 
                and the conductor <M>(R : K[[t]])</M> is not zero. If <M>v : K((t))\to {\mathbb Z}</M> is 
                the natural valuation for <M>K((t))</M>, then <M>v(R)</M> is a numerical semigroup.
                <P/>
                Let <M>S</M> be a numerical semigroup minimally generated by <M>\{n_1,\ldots,n_e\}</M>. 
                The semigroup ring associated to <M>S</M> is <M>K[[S]]=K[[t^{n_1},\ldots,t^{n_e}]]</M>. 
                A ring is called a semigroup ring if it is of the form <M>K[[S]]</M>, for some numerical 
                semigroup <M>S</M>. We say that <M>S</M> is a monomial numerical semigroup if for any 
                <M>R</M> as above with <M>v(R)=S</M>, <M>R</M> is a semigroup ring. See <Cite Key="VMic02"></Cite> for details.

                       <Example><![CDATA[
gap> IsMonomialNumericalSemigroup(NumericalSemigroup(4,6,7));
true
gap> IsMonomialNumericalSemigroup(NumericalSemigroup(4,6,11));
false
]]></Example>
                     </Description>
                </ManSection>


                <Heading>
                    Apéry sets of ideals of numerical semigroups
                </Heading>


                <ManSection>
                    <Func Arg="I,n" Name="AperyListOfIdealOfNumericalSemigroupWRTElement"></Func>
                    <Description>

 					Computes the sets of elements <M>x</M> of <A>I</A>  such that <M>x-</M><A>n</A> not in the ideal <A>I</A>,
					where <A>n</A> is supposed to be in the ambient semigroup of <A>I</A>.
					The element in the <M>i</M>th position of the output list (starting in 0) is congruent with <M>i</M> modulo <A>n</A>. 

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> i:=[12,14]+s;;
gap> AperyListOfIdealOfNumericalSemigroupWRTElement(i,10);
[ 40, 51, 12, 23, 14, 25, 36, 27, 38, 49 ]
]]></Example>
                     </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="s" Name="AperyTableOfNumericalSemigroup"></Func>
                    <Description>
				
				 Computes the Apéry table associated to the numerical semigroup <A>s</A> as explained in <Cite Key="CJZ"></Cite>, 
				 that is, a list containing the Apéry list of <A>s</A> with respect to its multiplicity and the Apéry lists of <M>kM</M> 
				(with <M>M</M> the maximal ideal of <A>s</A>) with respect to the multiplicity of <A>s</A>, for <M>k\in\{1,\ldots,r\}</M>,
				where <M>r</M> is the reduction number of <M>M</M>  (see ReductionNumberIdealNumericalSemigroup).

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> AperyTableOfNumericalSemigroup(s);
[ [ 0, 11, 22, 13, 24, 35, 26, 37, 48, 39 ], 
  [ 10, 11, 22, 13, 24, 35, 26, 37, 48, 39 ], 
  [ 20, 21, 22, 23, 24, 35, 26, 37, 48, 39 ], 
  [ 30, 31, 32, 33, 34, 35, 36, 37, 48, 39 ], 
  [ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 ] ]
]]></Example>
                     </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="i, is" Name="StarClosureOfIdealOfNumericalSemigroup"></Func>
                    <Description>
				
						<A>i</A> is an ideal and <A>is</A> is a set of ideals (all from the same numerical semigroup<M>s</M>). 
						The output is <M>i^{*_is}</M>, where <M>*_is</M> is the star operation generated by <A>is</A>: <M>(s-(s-i))\bigcap_{k\in is} (k-(k-i))</M>. 
						The implementation uses Section 3 of <Cite Key="Sp"></Cite>.

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> StarClosureOfIdealOfNumericalSemigroup([0,2]+s,[[0,4]+s]);;
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 0, 2, 4 ]
						]]></Example>
                     </Description>
                </ManSection>


</Section>

