<?xml version="1.0" encoding="UTF-8"?>



<Section>
                <Heading>
                    Definitions and basic operations
                </Heading>

                We describe in this section the basic functions to create and compute notable elements of ideals of numerical semigroups. We also include iterators and functions to treat ideals as lists, which easies the access to its elements.

                <ManSection>
                    <Func Arg="l,S" Name="IdealOfNumericalSemigroup"></Func>
                    <Func Arg="l,S" Name="+" Label="for defining ideal of numerical semigroup"></Func>
                    <Description>
                        <A>S</A> is a numerical semigroup and <A>l</A> a list of integers.
                        The output is the ideal of <A>S</A> generated by <A>l</A>.

                        <P/>
                        There are several shortcuts for this function, as shown in the example.
                        <Example><![CDATA[
gap> IdealOfNumericalSemigroup([3,5],NumericalSemigroup(9,11));
<Ideal of numerical semigroup>
gap> [3,5]+NumericalSemigroup(9,11);
<Ideal of numerical semigroup>
gap> last=last2;
true
gap> 3+NumericalSemigroup(5,9);
<Ideal of numerical semigroup>
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="Obj" Name="IsIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Tests if the object <A>Obj</A> is an ideal of a
                        numerical semigroup.

                        <Example><![CDATA[
gap> I:=[1..7]+NumericalSemigroup(7,19);;
gap> IsIdealOfNumericalSemigroup(I);
true
gap> IsIdealOfNumericalSemigroup(2);
false
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
<Attr Arg="I" Name="MinimalGenerators" Label="for ideal of numerical semigroup"></Attr>
<Attr Arg="I" Name="MinimalGeneratingSystem" Label="for ideal of numerical semigroup"></Attr>
                    <Attr Arg="I" Name="MinimalGeneratingSystemOfIdealOfNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the minimal system of generators of <A>I</A>.

                        <Example><![CDATA[
gap> MinimalGenerators([3,5]+NumericalSemigroup(2,11));
[ 3 ]
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> MinimalGeneratingSystem(I);
[ 3 ]
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I);
[ 3 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Attr Arg="I" Name="Generators" Label="for ideal of numerical semigroup"></Attr>
                    <Attr Arg="I" Name="GeneratorsOfIdealOfNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is a system of generators of the ideal.
			<P/>
			Remark: from Version 1.0.1 on, this value does not change even when a set of minimal generators is computed.


                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> Generators(I);
[ 3, 5, 9 ]
gap> GeneratorsOfIdealOfNumericalSemigroup(I);
[ 3, 5, 9 ]
gap> MinimalGenerators(I);
[ 3 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I" Name="AmbientNumericalSemigroupOfIdeal"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, say <M>S</M>.
                        The output is <M>S</M>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> AmbientNumericalSemigroupOfIdeal(I);
<Numerical semigroup with 2 generators>
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Prop Arg="I" Name="IsIntegral"></Prop>
                    <Prop Arg="I" Name="IsIntegralIdealOfNumericalSemigroup"></Prop>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, say <M>S</M>.
                        Detects if  <M>I\subseteq S</M>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> IsIntegral(10+s);
true
gap> IsIntegral(4+s);
false
gap> IsIntegralIdealOfNumericalSemigroup(10+s);
true
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
		  <Func Arg="I" Name="SmallElements" Label="for ideal of numerical semigroup"></Func>
                  <Func Arg="I" Name="SmallElementsOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is a list with the elements in <A>I</A> that are less than or equal
                        to the greatest integer not belonging to the ideal plus one.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> SmallElements(I);
[ 3, 5, 7, 9, 11, 13 ]
gap> SmallElements(I) = SmallElementsOfIdealOfNumericalSemigroup(I);
true
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> SmallElements(J);
[ 2, 4, 6, 8, 10 ]
]]></Example>
                    </Description>
                </ManSection>

		<ManSection>
                    <Attr Name="Conductor" Arg="NS" Label="for ideal of numerical semigroup"/>
                    <Func Arg="I" Name="ConductorOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the largest element in  <A>SmallElements(I)</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> Conductor(10+s);
15
gap> ConductorOfIdealOfNumericalSemigroup(10+s);
15
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Oper Name="Minimum" Arg="I" Label="minimum of ideal of numerical semigroup"/>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the minimum of <A>I</A>.

                        <Example><![CDATA[
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> Minimum(J);
2
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="n, I" Name="BelongsToIdealOfNumericalSemigroup"></Func>
                    <Oper Name="\in" Arg="n, I" Label="membership test in ideal of numerical semigroup"/>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is an integer.
                        The output is <C>true</C> if <A>n</A> belongs to <A>I</A>.

                        <P/>
                        <A> n in I</A> can be used for short.

                        <Example><![CDATA[
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> BelongsToIdealOfNumericalSemigroup(9,J);
false
gap> 9 in J;
false
gap> BelongsToIdealOfNumericalSemigroup(10,J);
true
gap> 10 in J;
true
]]></Example>
                    </Description>
                </ManSection>



				<ManSection>
					<Func Arg="I,r"  Name="ElementNumber_IdealOfNumericalSemigroup"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the <A>r</A>-th element of <A>I</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> ElementNumber_IdealOfNumericalSemigroup(I,10);
19
]]></Example>
					</Description>
</ManSection>

				<ManSection>
					<Func Arg="I,r"  Name="NumberElement_IdealOfNumericalSemigroup"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the position of <A>r</A> in <A>I</A> (and <C>fail</C> if the integer is not in the ideal).
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> NumberElement_IdealOfNumericalSemigroup(I,19);
10
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I,r"  Name="\[ \]" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the <A>r</A>-th element of <A>I</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> I[10];
19
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I,ls"  Name="\{ \}" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>ls</A> is a list of integers. 
                         It returns the list <A>[I[r] : r in ls]</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> I{[10..13]};
[ 19, 20, 21, 22 ]
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I"  Name="Iterator" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup. It returns an iterator over <A>I</A>.
						<Example><![CDATA[
gap> s:=NumericalSemigroup(4,10,11);;
gap> i:=[2,3]+s;;
gap> iter:=Iterator(i);
<iterator>
gap> NextIterator(iter);
2
gap> NextIterator(iter);
3
gap> NextIterator(iter);
6
gap> SmallElements(i);
[ 2, 3, 6, 7, 10 ]
]]></Example>
					</Description>
</ManSection>

                <ManSection>
                    <Func Arg="I, J" Name="SumIdealsOfNumericalSemigroup"></Func>
                    <Func Arg="I, J" Name="+" Label="for ideals of numerical semigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        The output is the sum of both ideals <M>\{ i+j \ |\  i\in <A>I</A>, j\in <A>J</A>\}</M>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> I+J;
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
gap> SumIdealsOfNumericalSemigroup(I,J);
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="n, I" Name="MultipleOfIdealOfNumericalSemigroup"></Func>
                    <Func Arg="n, I" Name="*" Label="for multiple of ideal of numerical semigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer.
                        The output is the ideal <M><A>I</A>+\cdots+<A>I</A></M> (<A>n</A> times).

                        <P/>
                        <A> n * I</A> can be used for short.

                        <Example><![CDATA[
gap> I:=[0,1]+NumericalSemigroup(3,5,7);;
gap> MultipleOfIdealOfNumericalSemigroup(2,I) = 2*I;
true
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(2*I);
[ 0, 1, 2 ]
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="I, J" Name="SubtractIdealsOfNumericalSemigroup"></Func>
                    <Func Arg="I, J" Name="-" Label="for ideals of numerical semigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        The output is the ideal <M>\{ z\in {\mathbb Z}\ |\  z+<A>J</A>\subseteq <A>I</A>\}</M>.

                        <P/>
                        <M>I - J</M> can be used as a short for <C>SubtractIdealsOfNumericalSemigroup(I,J)</C>.

                        <P/>
                        <M>S-</M><A>J</A> is a synonym of <M>(0+S)-</M><A>J</A>, if <M>S</M> is the ambient semigroup of <A>I</A> and <A>J</A>.

                        The following example appears in <Cite Key="HS04"></Cite>.
                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;;
gap> II:=S-I;;
gap> MinimalGenerators(I);
[ 0, 1 ]
gap> MinimalGenerators(II);
[ 14, 20 ]
gap> MinimalGenerators(I+II);
[ 14, 15, 20, 21 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Oper Name="Difference" Arg="I, J" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I, J" Name="DifferenceOfIdealsOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup. <A>J</A> must be contained in <A>I</A>.
                        The output is the set <M><A>I</A>\setminus <A>J</A></M>.

                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;
<Ideal of numerical semigroup>
gap> 2*I-2*I;
<Ideal of numerical semigroup>
gap> I-I;
<Ideal of numerical semigroup>
gap> ii := 2*I-2*I;
<Ideal of numerical semigroup>
gap> i := I-I;
<Ideal of numerical semigroup>
gap>  Difference(last2,last);
[ 26, 27, 37, 38 ]
gap> DifferenceOfIdealsOfNumericalSemigroup(ii,i);
[ 26, 27, 37, 38 ]
gap> Difference(i,ii);
[  ]
]]></Example>
                    </Description>
                </ManSection>


				<ManSection>
					<Func Arg="k, I" Name="TranslationOfIdealOfNumericalSemigroup"></Func>
	                    <Func Arg="k, I" Name="+" Label="translation of ideal of numerical semigroup"></Func>
				<Description>
			Given an ideal <A>I</A> of a numerical semigroup S and an integer <A>k</A>,
			returns an ideal of the numerical semigroup S generated by
			<M>\{i_1+k,\ldots,i_n+k\}</M>, where <M>\{i_1,\ldots,i_n\}</M> is the system of generators of <A>I</A>.
			<P/>
			As a synonym to <C>TranslationOfIdealOfNumericalSemigroup(k, I)</C> the expression
			<C>k + I</C> may be used.

						<Example><![CDATA[
gap> s:=NumericalSemigroup(13,23);;
gap> l:=List([1..6], _ -> Random([8..34]));
[ 22, 29, 34, 25, 10, 12 ]
gap> I:=IdealOfNumericalSemigroup(l, s);;
gap> It:=TranslationOfIdealOfNumericalSemigroup(7,I);
<Ideal of numerical semigroup>
gap> It2:=7+I;
<Ideal of numerical semigroup>
gap> It2=It;
true
]]></Example>
									</Description>
                </ManSection>

                <ManSection>
                    <Oper Name="Intersection" Arg="I, J" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I, J" Name="IntersectionIdealsOfNumericalSemigroup"></Func>
                    <Description>
Given two ideals <A>I</A> and <A>J</A> of a numerical semigroup <A>S</A>
returns the ideal of the numerical semigroup <A>S</A> which is the
intersection of the ideals <A>I</A> and <A>J</A>.

                        <Example><![CDATA[
gap> i:=IdealOfNumericalSemigroup([75,89],s);;
gap> j:=IdealOfNumericalSemigroup([115,289],s);;
gap> Intersection(i,j);
<Ideal of numerical semigroup>
gap> IntersectionIdealsOfNumericalSemigroup(i,j) = Intersection(i,j);
true
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="MaximalIdeal" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="MaximalIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the maximal ideal of the numerical semigroup <A>S</A>.

                        <Example><![CDATA[
gap> s := NumericalSemigroup(3,7);;                   
gap> MaximalIdeal(s);
<Ideal of numerical semigroup>
gap> MaximalIdealOfNumericalSemigroup(s) = MaximalIdeal(s);
true
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="CanonicalIdeal" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="CanonicalIdealOfNumericalSemigroup"></Func>
                    <Description>
		      <A>S</A> is a numerical semigroup.
                        Computes the (standard) canonical ideal of <A>S</A> (<Cite Key="BF97"></Cite>):
                        <M>\{ x \in \mathbb{Z} | g-x \not \in S\} </M>, where <M>g</M> is the Frobenius number of <A>S</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(4,6,11);;
gap> m:=MaximalIdeal(s);;
gap> c:=CanonicalIdeal(s);
<Ideal of numerical semigroup>
gap> c-(c-m)=m;
true
gap> id:=3+s;
<Ideal of numerical semigroup>
gap> c-(c-id)=id;
true
gap> CanonicalIdealOfNumericalSemigroup(s) = c;
true
]]></Example>
                    </Description>
                </ManSection>

<ManSection>
  <Prop Arg="E" Name="IsCanonicalIdeal"></Prop>
  <Prop Arg="E" Name="IsCanonicalIdealOfNumericalSemigroup"></Prop>
  <Description>
    <A>E</A> is an ideal of a numerical semigroup, say <M>S</M>. Determines if <A>E</A> is a translation of the canonical ideal of <M>S</M>, or equivalently, for every ideal <M>J</M>, <M>E-(E-J)=J</M>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> c:=3+CanonicalIdeal(s);;
gap> c-(c-(3+s))=3+s;
true
gap> IsCanonicalIdeal(c);
true
gap> IsCanonicalIdealOfNumericalSemigroup(c);
true
]]></Example>
    </Description>
</ManSection>

<ManSection>
    <Oper Arg="S" Name="TypeSequence" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="TypeSequenceOfNumericalSemigroup"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                         Computes the type sequence of a numerical semigroup. That is, the secuence <M>t_i(<A>S</A>)=\sharp(<A>S</A>(i)\setminus <A>S</A>(i-1))</M>, with <M><A>S</A>(i)=\{ s\in S\mid s\ge s_i\}</M> and <M>s_i</M> the <M>i</M>th element of <A>S</A>.
                         <P/>
                        This function is the implementation of the algorithm given in
                        <Cite Key="BDF97"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TypeSequence(s);
[ 13, 3, 4, 4, 7, 3, 3, 3, 2, 2, 2, 3, 3, 2, 4, 3, 2, 1, 3, 2, 1, 1, 2, 2, 1,
  1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
  1, 1, 1 ]
gap> s:=NumericalSemigroup(4,6,11);;
gap> TypeSequenceOfNumericalSemigroup(s);
[ 1, 1, 1, 1, 1, 1, 1 ]
]]></Example>
                    </Description>
</ManSection>

</Section>

<Section>
                <Heading>
                    Blow ups and closures
                </Heading>
                The blow up of an ideal <M>I</M> of a numerical semigroup is the ideal  <M>\bigcup_{n\geq 0} n<A>I</A>-n<A>I</A></M>. In this section we provide functions to compute the blow up and related invariants.
                <ManSection>
                    <Func Arg="n, I" Name="HilbertFunctionOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer. <A>I</A> must be contained in its ambient semigroup.
                        The output is the cardinality of the set <M><A>n</A><A>I</A>\setminus (<A>n</A>+1)<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[6,9,11]+NumericalSemigroup(6,9,11);;
gap> List([1..7],n->HilbertFunctionOfIdealOfNumericalSemigroup(n,I));
[ 3, 5, 6, 6, 6, 6, 6 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Attr Arg="I" Name="HilbertFunction"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup. <A>I</A> must be contained in its ambient semigroup (integral ideal).
                        The output is a function that maps to each <M>n</M> the cardinality of the set <M>n<A>I</A>\setminus (n+1)<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[6,9,11]+NumericalSemigroup(6,9,11);;
gap> List([1..7],n->HilbertFunction(I)(n));
[ 3, 5, 6, 6, 6, 6, 6 ]
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Oper Arg="I" Name="BlowUp" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I" Name="BlowUpIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
The output is the ideal <M>\bigcup_{n\geq 0} n<A>I</A>-n<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> BlowUp(I);
<Ideal of numerical semigroup>
gap> SmallElements(last);
[ 0, 2, 4, 6, 8 ]
gap> BlowUpIdealOfNumericalSemigroup(I);;
gap> SmallElementsOfIdealOfNumericalSemigroup(last);
[ 0, 2, 4, 6, 8 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Attr Arg="I" Name="ReductionNumber" Label="for ideals of numerical semigroups"></Attr>
                    <Attr Arg="I" Name="ReductionNumberIdealNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the least integer
                        such that  <M>n <A>I</A> + i=(n+1)<A>I</A></M>, where <M>i=min(<A>I</A>)</M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> ReductionNumber(I);
2
gap> ReductionNumberIdealNumericalSemigroup(I);
2
]]></Example>
                    </Description>
                </ManSection>





<ManSection>
                    <Oper Arg="S" Name="BlowUp" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="BlowUpOfNumericalSemigroup"></Func>
                    <Description>
		      <A>S</A> is a numerical semigroup.
                        If <A>M</A> is the maximal ideal of the numerical semigroup, then
                        the output is the numerical semigroup
                        <M>\bigcup_{n\geq 0} n<A>M</A>-n<A>M</A></M>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BlowUp(s);
<Numerical semigroup with 10 generators>
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
gap> BlowUpOfNumericalSemigroup(s);;
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
gap> m:=MaximalIdeal(s);
<Ideal of numerical semigroup>
gap> BlowUp(m);
<Ideal of numerical semigroup>
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
]]></Example>
                    </Description>
                </ManSection>
  <ManSection>
      <Func Name="LipmanSemigroup" Arg="S"></Func>
      <Description>
       This is just a synonym of <Ref Func="BlowUpOfNumericalSemigroup"/>.
      <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> LipmanSemigroup(s);
<Numerical semigroup with 10 generators>
gap> SmallElementsOfNumericalSemigroup(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
]]></Example>

</Description>
</ManSection>


                <ManSection>
    <Oper Arg="I" Name="RatliffRushNumber"/>
                    <Func Arg="I" Name="RatliffRushNumberOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the least integer
                        such that  <M>(n+1)<A>I</A>-n<A>I</A></M> is the Ratliff-Rush closure of <A>I</A> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> RatliffRushNumber(I);
1
gap> RatliffRushNumberOfIdealOfNumericalSemigroup(I);
1
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
    <Oper Arg="I" Name="RatliffRushClosure"/>
                    <Func Arg="I" Name="RatliffRushClosureOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the Ratliff-Rush closure of <A>I</A>:  <M>\bigcup_{n\in \mathbb{N}}(n+1)<A>I</A>-n<A>I</A></M> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> RatliffRushClosure(I);
<Ideal of numerical semigroup>
gap> MinimalGenerators(last);
[ 0, 2, 4 ]
gap> RatliffRushClosureOfIdealOfNumericalSemigroup(I) = RatliffRushClosure(I);
true
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
    <Oper Arg="I" Name="AsymptoticRatliffRushNumber"/>
                    <Func Arg="I" Name="AsymptoticRatliffRushNumberOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the least <M>n</M> such that the Ratliff-Rush closure of <M>m<A>I</A></M> equals <M>m<A>I</A></M> for all <M>m\ge n</M> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> AsymptoticRatliffRushNumber(I);
2
gap> AsymptoticRatliffRushNumberOfIdealOfNumericalSemigroup(I);
2
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="MultiplicitySequence"/>
    <Func Name="MultiplicitySequenceOfNumericalSemigroup" Arg="S"/>
    <Description>
     <A>S</A> is a numerical semigroup. The output is a list with the multiplicities of the sequence <M>S\subseteq L(S)\subseteq \cdots \subseteq \mathbb{N}</M>, where <M>L(\cdot)</M> means <Ref Func="LipmanSemigroup"/>.
    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5);;
gap> MultiplicitySequence(s);
[ 3, 2, 1 ]
gap> MultiplicitySequenceOfNumericalSemigroup(s);
[ 3, 2, 1 ]
]]></Example>
</Description>
</ManSection>


<ManSection>
    <Oper Arg="S" Name="MicroInvariants"/>
                    <Func Arg="S" Name="MicroInvariantsOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the microinvariants of the numerical semigroup <A>S</A> defined
                        in <Cite Key="E01"></Cite>. For their computation we have used the formula
                        given in <Cite Key="BF06"></Cite>. The Apéry set of <A>S</A> and its
                        blow up are involved in this computation.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> bu:=BlowUpOfNumericalSemigroup(s);;
gap> ap:=AperyListOfNumericalSemigroupWRTElement(s,30);;
gap> apbu:=AperyListOfNumericalSemigroupWRTElement(bu,30);;
gap> (ap-apbu)/30;
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> MicroInvariants(s)=last;
true
gap> MicroInvariantsOfNumericalSemigroup(s)=MicroInvariants(s);
true
]]></Example>
                    </Description>
                </ManSection>




                <Heading>
                    Apéry sets of ideals of numerical semigroups
                </Heading>


                <ManSection>
                    <Oper Arg="I,n" Name="AperyList"/>
                    <Func Arg="I,n" Name="AperyListOfIdealOfNumericalSemigroupWRTElement"></Func>
                    <Description>
<A>I</A> is an ideal and <A>n</A> is an integer.
 					Computes the set of elements <M>x</M> of <A>I</A>  such that <M>x-</M><A>n</A> is not in the ideal <A>I</A>,
					where <A>n</A> is supposed to be in the ambient semigroup of <A>I</A>.
					The element in the <M>i</M>th position of the output list (starting in 0) is congruent with <M>i</M> modulo <A>n</A>.

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> i:=[12,14]+s;;
gap> AperyList(i,10);
[ 40, 51, 12, 23, 14, 25, 36, 27, 38, 49 ]
gap> AperyListOfIdealOfNumericalSemigroupWRTElement(i,10);
[ 40, 51, 12, 23, 14, 25, 36, 27, 38, 49 ]
]]></Example>
                     </Description>
                </ManSection>


                <ManSection>
                    <Oper Arg="S" Name="AperyTable"/>
                    <Func Arg="s" Name="AperyTableOfNumericalSemigroup"></Func>
                    <Description>

				 Computes the Apéry table associated to the numerical semigroup <A>s</A> as explained in <Cite Key="CJZ"></Cite>,
				 that is, a list containing the Apéry list of <A>s</A> with respect to its multiplicity and the Apéry lists of <M>kM</M>
				(with <M>M</M> the maximal ideal of <A>s</A>) with respect to the multiplicity of <A>s</A>, for <M>k\in\{1,\ldots,r\}</M>,
				where <M>r</M> is the reduction number of <M>M</M>  (see <Ref Func="ReductionNumberIdealNumericalSemigroup"/>).

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> AperyTable(s);
[ [ 0, 11, 22, 13, 24, 35, 26, 37, 48, 39 ],
  [ 10, 11, 22, 13, 24, 35, 26, 37, 48, 39 ],
  [ 20, 21, 22, 23, 24, 35, 26, 37, 48, 39 ],
  [ 30, 31, 32, 33, 34, 35, 36, 37, 48, 39 ],
  [ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 ] ]
gap> AperyTableOfNumericalSemigroup(s) = AperyTable(s);
true
]]></Example>
                     </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="i, is" Name="StarClosureOfIdealOfNumericalSemigroup"></Func>
                    <Description>

						<A>i</A> is an ideal and <A>is</A> is a set of ideals (all from the same numerical semigroup<M>s</M>).
						The output is <M>i^{*_{is}}</M>, where <M>*_{is}</M> is the star operation generated by <A>is</A>: <M>(s-(s-i))\bigcap_{k\in is} (k-(k-i))</M>.
						The implementation uses Section 3 of <Cite Key="MR3354072"></Cite>.

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> StarClosureOfIdealOfNumericalSemigroup([0,2]+s,[[0,4]+s]);;
gap> MinimalGenerators(last);
[ 0, 2, 4 ]
]]></Example>
                     </Description>
                </ManSection>


</Section>


<Section Label="sec:PatternsIdeals">
<Heading>
    Patterns for ideals
</Heading>

In this section we document the functions implemented by K. Stokes related to patterns of ideals in numerical semigroups. The correctness of the algorithms can be found in <Cite Key="Stokes"></Cite>.


<ManSection>
  <Func Arg="p" Name="IsAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns <C>true</C> or <C>false</C> depending if the pattern is admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,1,-1]);
true
gap> IsAdmissiblePattern([1,-2]);
false
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p" Name="IsStronglyAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns <C>true</C> or <C>false</C> depending if the pattern is strongly admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,-1]);
true
gap> IsStronglyAdmissiblePattern([1,-1]);
false
gap> IsStronglyAdmissiblePattern([1,1,-1]);
true
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="I,T" Name="AsIdealOfNumericalSemigroup"></Func>
  <Description>

    <A>I</A> is an ideal of a numerical semigroup <M>S</M>, and <A>T</A> is a numerical semigroup. Detects if <A>I</A> is an ideal of <A>T</A> and contained in <A>T</A> (integral ideal), and if so, returns <A>I</A> as an ideal of <A>T</A>. It returns <C>fail</C> if <A>I</A> is an ideal of some semigroup but not an integral ideal of <A>T</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> t:=NumericalSemigroup(10,11,14);;
gap> AsIdealOfNumericalSemigroup(10+s,t);
fail
gap> AsIdealOfNumericalSemigroup(100+s,t);
<Ideal of numerical semigroup>
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,C" Name="BoundForConductorOfImageOfPattern"></Func>
  <Description>

     <A>p</A> is the list of integers that are the coefficients of an admissible pattern. <A>C</A> is a positive integer.

     Calculates an upper bound of the smallest element <M>K</M> in <M>p(I)</M> such that all integers larger than <M>K</M> belong to <M>p(I)</M>, where <M>I</M> is an ideal of a
numerical semigroup. Instead of taking <M>I</M> as parameter, the function takes <M>C</M>, which is assumed to be the conductor of <M>I</M>.
    <Example><![CDATA[
gap> BoundForConductorOfImageOfPattern([1,1,-1],10);
10
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,I" Name="ApplyPatternToIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> is an ideal of a numerical semigroup.<P/>

    Outputs <M>p(I)</M>, represented as <C>[d,p(I)/d]</C>, where <C>d</C > is the gcd of the coefficients of <A>p</A>. All elements of <M>p(I)</M> are divisible by <M>d</M>, and <M>p(I)/d</M> is an ideal of some numerical semigroup. It is returned as the maximal ideal of the numerical semigroup <M>p(I)/d \cup \{0\}</M>. The ambient numerical semigroup can later be changed with the function <C>AsIdealOfNumericalSemigroup</C>.


     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=10+s;;
gap> ApplyPatternToIdeal([1,1,-1],i);
[ 1, <Ideal of numerical semigroup> ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,S" Name="ApplyPatternToNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> is  a numerical semigroup.<P/>

    Outputs <C>ApplyPatternToIdeal(p,0+S)</C>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> ApplyPatternToNumericalSemigroup([1,1,-1],s);
[ 1, <Ideal of numerical semigroup> ]
gap> SmallElements(last[2]);
[ 0, 3, 5 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,I,J" Name="IsAdmittedPatternByIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> and <A>J</A> are ideals of certain numerical semigroups.<P/>


    Tests whether or not <M>p(I)</M> is contained in <A>J</A>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=[3,5]+s;;
gap> IsAdmittedPatternByIdeal([1,1,-1],i,i);
false
gap> IsAdmittedPatternByIdeal([1,1,-1],i,0+s);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,S,T" Name="IsAdmittedPatternByNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> and <A>T</A> are numerical semigroups.<P/>


    Tests whether or not <M>p(S)</M> is contained in <A>T</A>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> IsAdmittedPatternByNumericalSemigroup([1,1,-1],s,s);
true
gap> IsArfNumericalSemigroup(s);
true
]]></Example>
  </Description>
</ManSection>



</Section>

<Section>
  <Heading>Graded associated ring of numerical semigroup</Heading>

  This section contains several functions to test properties of the graded (with respect to the maximal ideal) semigroup ring <M>\mathbb{K}[\![S]\!]</M> (with <M>S</M> a numerical semigroup).

  <ManSection>
                      <Prop Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCM"></Prop>
                      <Description>
                          <A>S</A> is a numerical semigroup.
                          Returns <C>true</C> if the graded ring associated to <M>K[[<A>S</A>]]</M>
                          is Cohen-Macaulay, and <C>false</C> otherwise.
                          This test is the implementation of the algorithm given in
                          <Cite Key="BF06"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupBuchsbaum"/>.
                          <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
false
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,30),
> w->MaximumDegreeOfElementWRTNumericalSemigroup (w,s));
[ 0, 1, 4, 1, 2, 1, 3, 1, 4, 3, 2, 3, 1, 1, 4, 3, 3, 1, 4, 1, 4, 3, 2, 4, 2,
  5, 4, 3, 1, 2 ]
gap> last=last2;
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
true
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 2, 1, 1 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,4),
> w->MaximumDegreeOfElementWRTNumericalSemigroup(w,s));
[ 0, 2, 1, 1 ]
  ]]></Example>
                      </Description>
                  </ManSection>

<ManSection>
                    <Prop Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupBuchsbaum"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the graded ring associated to <M>K[\![<A>S</A>]\!]</M>
                        is Buchsbaum, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in <Cite Key="DA-M-M"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
                    </Description>
</ManSection>


<ManSection>
  <Func Arg="S" Name="TorsionOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the set of elements in the numerical semigroup <A>S</A> corresponding to a <M>\mathbb{K}</M>-basis of the torsion submodule of the associated graded ring of the numerical semigroup ring <M>\mathbb{K}[\![S]\!]</M>. It uses the Apery table as explained in <Cite Key="CJZ"></Cite>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TorsionOfAssociatedGradedRingNumericalSemigroup(s);
[ 181, 153, 157, 193, 169, 148 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the smallest non-negative integer <M>k</M> for which the associated graded ring <M>G</M> of a given numerical semigroup ring is <M>k</M>-Buchsbaum, that is, the least <M>k</M> for which the torsion submodule of <M>G</M> is annihilated by the <M>k</M>-th power of the homogeneous maximal ideal of <M>G</M>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup(s);
1
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
                    <Prop Arg="S" Name="IsMpure"></Prop>
                    <Prop Arg="S" Name="IsMpureNumericalSemigroup"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the M-Purity of the numerical semigroup S <A>S</A>.
			This test is based on
                        <Cite Key="Br"></Cite>.

            <P/>
            This filter implies <Ref Func="IsPureNumericalSemigroup"/>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsMpure(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsMpureNumericalSemigroup(s);
true
]]></Example>
                    </Description>
</ManSection>

<ManSection>
                    <Prop Arg="S" Name="IsPure"></Prop>
                    <Prop Arg="S" Name="IsPureNumericalSemigroup"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Test for the purity of the numerical semigroup S <A>S</A>.
			This test is based on
                        <Cite Key="Br"></Cite>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsPure(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsPureNumericalSemigroup(s);
true
]]></Example>
                    </Description>
</ManSection>

<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupGorenstein"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the graded ring associated to <M>K[[<A>S</A>]]</M>
                        is Gorenstein, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DA-M-S"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupCM"/>, <Ref Func="IsMpureNumericalSemigroup"/>, and <Ref Func="IsSymmetricNumericalSemigroup"/>.
                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
true
]]></Example>
                    </Description>
</ManSection>


<!--the functions below first appeared in version 0.98-->
<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCI"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the Complete Intersection property of the associated graded ring of a numerical semigroup ring associated to <M>K[[<A>S</A>]]</M>, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSwhen"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupGorenstein"/> and <Ref Func="IsAperySetGammaRectangular"/>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
true
]]></Example>
                    </Description>
                </ManSection>


</Section>
