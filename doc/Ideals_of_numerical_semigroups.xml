<?xml version="1.0" encoding="UTF-8"?>



<Section>
                <Heading>
                    Definitions and basic operations
                </Heading>

                We describe in this section the basic functions to create and compute notable elements of ideals of numerical semigroups. We also include iterators and functions to treat ideals as lists, which easies the access to its elements.

                <ManSection>
                    <Func Arg="l,S" Name="IdealOfNumericalSemigroup"></Func>
                    <Func Arg="l,S" Name="+" Label="for defining ideal of numerical semigroup"></Func>
                    <Description>
                        <A>S</A> is a numerical semigroup and <A>l</A> a list of integers.
                        The output is the ideal of <A>S</A> generated by <A>l</A>.

                        <P/>
                        There are several shortcuts for this function, as shown in the example.
                        <Example><![CDATA[
gap> IdealOfNumericalSemigroup([3,5],NumericalSemigroup(9,11));
<Ideal of numerical semigroup>
gap> [3,5]+NumericalSemigroup(9,11);
<Ideal of numerical semigroup>
gap> last=last2;
true
gap> 3+NumericalSemigroup(5,9);
<Ideal of numerical semigroup>
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="Obj" Name="IsIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Tests if the object <A>Obj</A> is an ideal of a
                        numerical semigroup.

                        <Example><![CDATA[
gap> I:=[1..7]+NumericalSemigroup(7,19);;
gap> IsIdealOfNumericalSemigroup(I);
true
gap> IsIdealOfNumericalSemigroup(2);
false
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
<Attr Arg="I" Name="MinimalGenerators" Label="for ideal of numerical semigroup"></Attr>
<Attr Arg="I" Name="MinimalGeneratingSystem" Label="for ideal of numerical semigroup"></Attr>
                    <Attr Arg="I" Name="MinimalGeneratingSystemOfIdealOfNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the minimal system of generators of <A>I</A>.

                        <Example><![CDATA[
gap> MinimalGenerators([3,5]+NumericalSemigroup(2,11));
[ 3 ]
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> MinimalGeneratingSystem(I);
[ 3 ]
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(I);
[ 3 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Attr Arg="I" Name="Generators" Label="for ideal of numerical semigroup"></Attr>
                    <Attr Arg="I" Name="GeneratorsOfIdealOfNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is a system of generators of the ideal.
			<P/>
			Remark: from Version 1.0.1 on, this value does not change even when a set of minimal generators is computed.


                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> Generators(I);
[ 3, 5, 9 ]
gap> GeneratorsOfIdealOfNumericalSemigroup(I);
[ 3, 5, 9 ]
gap> MinimalGenerators(I);
[ 3 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Func Arg="I" Name="AmbientNumericalSemigroupOfIdeal"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, say <M>S</M>.
                        The output is <M>S</M>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> AmbientNumericalSemigroupOfIdeal(I);
<Numerical semigroup with 2 generators>
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Prop Arg="I" Name="IsIntegral" Label="for ideal of numerical semigroup"></Prop>
                    <Prop Arg="I" Name="IsIntegralIdealOfNumericalSemigroup"></Prop>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, say <M>S</M>.
                        Detects if  <M>I\subseteq S</M>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> IsIntegral(10+s);
true
gap> IsIntegral(4+s);
false
gap> IsIntegralIdealOfNumericalSemigroup(10+s);
true
]]></Example>
                    </Description>
                </ManSection>



    <ManSection>
	    <Oper Arg="X,S" Name="IsComplementOfIntegralIdeal"></Oper>
            <Description>
            <A>S</A> is a numerical semigroup and <A>X</A> is a subset of <A>S</A>. Determines if the subset <A>X</A> of <A>S</A> is the complement of an integral ideal of <A>S</A>.
            <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,15,19);;
gap> i:=[20,21,25]+s;;
gap> d:=Difference(0+s,i);
[ 0, 10, 11, 15, 19, 22, 26, 29, 33, 34, 37, 38, 48 ]
gap> IsComplementOfIntegralIdeal(d,s);
true
gap> d:=DivisorsOfElementInNumericalSemigroup(50,s);
[ 0, 10, 11, 15, 19, 20, 21, 25, 29, 30, 31, 35, 39, 40, 50 ]
gap> IsComplementOfIntegralIdeal(d,s);
true            
]]></Example>
            </Description>
    </ManSection>

    <ManSection>
	    <Oper Arg="X,S" Name="IdealByDivisorClosedSet"></Oper>
            <Description>
            <A>S</A> is a numerical semigroup and <A>X</A> is a subset of <A>S</A> with the following property: for all <M>x</M> in <A>X</A> and every <M>y</M> in <A>S</A> with <M>x-y</M> in <A>S</A>, the integer <M>y</M> is also in <A>X</A>. The output is the integral ideal <M><A>S</A>\setminus <A>X</A></M>.
            <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,15,19);;
gap> i:=[20,21,25]+s;;
gap> d:=Difference(0+s,i);
[ 0, 10, 11, 15, 19, 22, 26, 29, 33, 34, 37, 38, 48 ]
gap> i=IdealByDivisorClosedSet(d,s);
true
]]></Example>
            </Description>
        </ManSection>

                <ManSection>
		  <Func Arg="I" Name="SmallElements" Label="for ideal of numerical semigroup"></Func>
                  <Func Arg="I" Name="SmallElementsOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is a list with the elements in <A>I</A> that are less than or equal
                        to the greatest integer not belonging to the ideal plus one.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> SmallElements(I);
[ 3, 5, 7, 9, 11, 13 ]
gap> SmallElements(I) = SmallElementsOfIdealOfNumericalSemigroup(I);
true
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> SmallElements(J);
[ 2, 4, 6, 8, 10 ]
]]></Example>
                    </Description>
                </ManSection>

<ManSection>
            <Attr Name="Conductor" Arg="I" Label="for ideal of numerical semigroup"/>
            <Func Arg="I" Name="ConductorOfIdealOfNumericalSemigroup"></Func>
            <Description>
                <A>I</A> is an ideal of a numerical semigroup.
                The output is the largest element in  <A>SmallElements(I)</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> Conductor(10+s);
15
gap> ConductorOfIdealOfNumericalSemigroup(10+s);
15
]]></Example>
    </Description>
</ManSection>

<ManSection>
            <Attr Name="FrobeniusNumber" Arg="I" Label="for ideal of numerical semigroup"/>
            <Func Arg="I" Name="FrobeniusNumberOfIdealOfNumericalSemigroup"></Func>
            <Description>
                <A>I</A> is an ideal of a numerical semigroup.
                The output is the largest element not belonging to <A>I</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> FrobeniusNumber(0+s);
4
]]></Example>
    </Description>
</ManSection>

<ManSection>
    <Attr Name="PseudoFrobenius" Arg="I" Label="for ideal of numerical semigroup"/>
    <Attr Name="PseudoFrobeniusOfIdealOfNumericalSemigroup" Arg="I" Label="for ideal of numerical semigroup"/>
    <Description>
        <A>I</A> is an ideal of a numerical semigroup.
        The output is the set of pseudo-Frobenius numbers of  <A>I</A>, that is the set <M><A>I</A>-M\setminus <A>I</A></M>, with <M>M</M> the maximal ideal of the ambient semigroup of <A>I</A> (see <Cite Key="nsapp2"></Cite>).

                <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> i:=4+s;;
gap> PseudoFrobenius(i);
[ 6, 8 ]
gap> PseudoFrobenius(s)=PseudoFrobenius(0+s);
true
]]></Example>
    </Description>
</ManSection>

<ManSection>
    <Oper Name="Type" Arg="I" Label="for ideal of numerical semigroup"/>
    <Description>
        <A>I</A> is an ideal of a numerical semigroup.
        The output is the cardinality of the set of pseudo-Frobenius numbers of  <A>I</A> (see <Cite Key="gas-semigroups"></Cite>).

                <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> k:=CanonicalIdeal(s);;
gap> Type(k);
1
]]></Example>
    </Description>
</ManSection>


                <ManSection>
                    <Oper Name="Minimum" Arg="I" Label="minimum of ideal of numerical semigroup"/>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the minimum of <A>I</A>.

                        <Example><![CDATA[
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> Minimum(J);
2
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="n, I" Name="BelongsToIdealOfNumericalSemigroup"></Func>
                    <Oper Name="\in" Arg="n, I" Label="membership test in ideal of numerical semigroup"/>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is an integer.
                        The output is <C>true</C> if <A>n</A> belongs to <A>I</A>.

                        <P/>
                        <A> n in I</A> can be used for short.

                        <Example><![CDATA[
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> BelongsToIdealOfNumericalSemigroup(9,J);
false
gap> 9 in J;
false
gap> BelongsToIdealOfNumericalSemigroup(10,J);
true
gap> 10 in J;
true
]]></Example>
                    </Description>
                </ManSection>



				<ManSection>
					<Func Arg="I,r"  Name="ElementNumber_IdealOfNumericalSemigroup"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the <A>r</A>-th element of <A>I</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> ElementNumber_IdealOfNumericalSemigroup(I,10);
19
]]></Example>
					</Description>
</ManSection>

				<ManSection>
					<Func Arg="I,r"  Name="NumberElement_IdealOfNumericalSemigroup"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the position of <A>r</A> in <A>I</A> (and <C>fail</C> if the integer is not in the ideal).
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> NumberElement_IdealOfNumericalSemigroup(I,19);
10
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I,r"  Name="\[ \]" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>r</A> is an integer. 
                         It returns the <A>r</A>-th element of <A>I</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> I[10];
19
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I,ls"  Name="\{ \}" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup and <A>ls</A> is a list of integers. 
                         It returns the list <A>[I[r] : r in ls]</A>.
						<Example><![CDATA[
gap> I := [2,5]+ NumericalSemigroup(7,8,17);;
gap> I{[10..13]};
[ 19, 20, 21, 22 ]
]]></Example>
					</Description>
</ManSection>


				<ManSection>
					<Oper Arg="I"  Name="Iterator" Label="for ideals of numerical semigroups"/>
					<Description>
						 <A>I</A> is an ideal of a numerical semigroup. It returns an iterator over <A>I</A>.
						<Example><![CDATA[
gap> s:=NumericalSemigroup(4,10,11);;
gap> i:=[2,3]+s;;
gap> iter:=Iterator(i);
<iterator>
gap> NextIterator(iter);
2
gap> NextIterator(iter);
3
gap> NextIterator(iter);
6
gap> SmallElements(i);
[ 2, 3, 6, 7, 10 ]
]]></Example>
					</Description>
</ManSection>

                <ManSection>
                    <Func Arg="I, J" Name="SumIdealsOfNumericalSemigroup"></Func>
                    <Func Arg="I, J" Name="+" Label="for ideals of numerical semigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        The output is the sum of both ideals <M>\{ i+j \ |\  i\in <A>I</A>, j\in <A>J</A>\}</M>.

                        <Example><![CDATA[
gap> I:=[3,5,9]+NumericalSemigroup(2,11);;
gap> J:=[2,11]+NumericalSemigroup(2,11);;
gap> I+J;
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
gap> SumIdealsOfNumericalSemigroup(I,J);
<Ideal of numerical semigroup>
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(last);
[ 5, 14 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="n, I" Name="MultipleOfIdealOfNumericalSemigroup"></Func>
                    <Func Arg="n, I" Name="*" Label="for multiple of ideal of numerical semigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer.
                        The output is the ideal <M><A>I</A>+\cdots+<A>I</A></M> (<A>n</A> times).

                        <P/>
                        <A> n * I</A> can be used for short.

                        <Example><![CDATA[
gap> I:=[0,1]+NumericalSemigroup(3,5,7);;
gap> MultipleOfIdealOfNumericalSemigroup(2,I) = 2*I;
true
gap> MinimalGeneratingSystemOfIdealOfNumericalSemigroup(2*I);
[ 0, 1, 2 ]
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Func Arg="I, J" Name="SubtractIdealsOfNumericalSemigroup"></Func>
                    <Func Arg="I, J" Name="-" Label="for ideals of numerical semigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup.
                        The output is the ideal <M>\{ z\in {\mathbb Z}\ |\  z+<A>J</A>\subseteq <A>I</A>\}</M>.

                        <P/>
                        <M>I - J</M> can be used as a short for <C>SubtractIdealsOfNumericalSemigroup(I,J)</C>.

                        <P/>
                        <M>S-</M><A>J</A> is a synonym of <M>(0+S)-</M><A>J</A>, if <M>S</M> is the ambient semigroup of <A>I</A> and <A>J</A>.

                        The following example appears in <Cite Key="HS04"></Cite>.
                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;;
gap> II:=S-I;;
gap> MinimalGenerators(I);
[ 0, 1 ]
gap> MinimalGenerators(II);
[ 14, 20 ]
gap> MinimalGenerators(I+II);
[ 14, 15, 20, 21 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Oper Name="Difference" Arg="I, J" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I, J" Name="DifferenceOfIdealsOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I, J</A> are ideals of a numerical semigroup. <A>J</A> must be contained in <A>I</A>.
                        The output is the set <M><A>I</A>\setminus <A>J</A></M>.

                        <Example><![CDATA[
gap> S:=NumericalSemigroup(14, 15, 20, 21, 25);;
gap> I:=[0,1]+S;
<Ideal of numerical semigroup>
gap> 2*I-2*I;
<Ideal of numerical semigroup>
gap> I-I;
<Ideal of numerical semigroup>
gap> ii := 2*I-2*I;
<Ideal of numerical semigroup>
gap> i := I-I;
<Ideal of numerical semigroup>
gap>  Difference(last2,last);
[ 26, 27, 37, 38 ]
gap> DifferenceOfIdealsOfNumericalSemigroup(ii,i);
[ 26, 27, 37, 38 ]
gap> Difference(i,ii);
[  ]
]]></Example>
                    </Description>
                </ManSection>


				<ManSection>
					<Func Arg="k, I" Name="TranslationOfIdealOfNumericalSemigroup"></Func>
	                    <Func Arg="k, I" Name="+" Label="translation of ideal of numerical semigroup"></Func>
				<Description>
			Given an ideal <A>I</A> of a numerical semigroup S and an integer <A>k</A>,
			returns an ideal of the numerical semigroup S generated by
			<M>\{i_1+k,\ldots,i_n+k\}</M>, where <M>\{i_1,\ldots,i_n\}</M> is the system of generators of <A>I</A>.
			<P/>
			As a synonym to <C>TranslationOfIdealOfNumericalSemigroup(k, I)</C> the expression
			<C>k + I</C> may be used.

						<Example><![CDATA[
gap> s:=NumericalSemigroup(13,23);;
gap> l:=List([1..6], _ -> Random([8..34]));
[ 22, 29, 34, 25, 10, 12 ]
gap> I:=IdealOfNumericalSemigroup(l, s);;
gap> It:=TranslationOfIdealOfNumericalSemigroup(7,I);
<Ideal of numerical semigroup>
gap> It2:=7+I;
<Ideal of numerical semigroup>
gap> It2=It;
true
]]></Example>
									</Description>
                </ManSection>

<ManSection>
    <Func Arg="I, J" Name="Union" Label="for ideals of numerical semigroup"></Func>
    <Description>
        <A>I, J</A> are ideals of a numerical semigroup.
        The output is the union of both ideals.
    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> I:=2+s;;
gap> J:=3+s;;
gap> Union(I,J);
<Ideal of numerical semigroup>
gap> Generators(last);
[ 2, 3 ]
]]></Example>
      </Description>
  </ManSection>


                <ManSection>
                    <Oper Name="Intersection" Arg="I, J" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I, J" Name="IntersectionIdealsOfNumericalSemigroup"></Func>
                    <Description>
Given two ideals <A>I</A> and <A>J</A> of a numerical semigroup <A>S</A>
returns the ideal of the numerical semigroup <A>S</A> which is the
intersection of the ideals <A>I</A> and <A>J</A>.

                        <Example><![CDATA[
gap> i:=IdealOfNumericalSemigroup([75,89],s);;
gap> j:=IdealOfNumericalSemigroup([115,289],s);;
gap> Intersection(i,j);
<Ideal of numerical semigroup>
gap> IntersectionIdealsOfNumericalSemigroup(i,j) = Intersection(i,j);
true
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="MaximalIdeal" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="MaximalIdealOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the maximal ideal of the numerical semigroup <A>S</A>.

                        <Example><![CDATA[
gap> s := NumericalSemigroup(3,7);;                   
gap> MaximalIdeal(s);
<Ideal of numerical semigroup>
gap> MaximalIdealOfNumericalSemigroup(s) = MaximalIdeal(s);
true
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="CanonicalIdeal" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="CanonicalIdealOfNumericalSemigroup"></Func>
                    <Description>
		      <A>S</A> is a numerical semigroup.
                        Computes the (standard) canonical ideal of <A>S</A> (<Cite Key="BF97"></Cite>):
                        <M>\{ x \in \mathbb{Z} | g-x \not \in S\} </M>, where <M>g</M> is the Frobenius number of <A>S</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(4,6,11);;
gap> m:=MaximalIdeal(s);;
gap> c:=CanonicalIdeal(s);
<Ideal of numerical semigroup>
gap> c-(c-m)=m;
true
gap> id:=3+s;
<Ideal of numerical semigroup>
gap> c-(c-id)=id;
true
gap> CanonicalIdealOfNumericalSemigroup(s) = c;
true
]]></Example>
    </Description>
</ManSection>

<ManSection>
  <Prop Arg="E" Name="IsCanonicalIdeal"></Prop>
  <Prop Arg="E" Name="IsCanonicalIdealOfNumericalSemigroup"></Prop>
  <Description>
    <A>E</A> is an ideal of a numerical semigroup, say <M>S</M>. Determines if <A>E</A> is a translation of the canonical ideal of <M>S</M>, or equivalently, for every ideal <M>J</M>, <M>E-(E-J)=J</M>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> c:=3+CanonicalIdeal(s);;
gap> c-(c-(3+s))=3+s;
true
gap> IsCanonicalIdeal(c);
true
gap> IsCanonicalIdealOfNumericalSemigroup(c);
true
]]></Example>
    </Description>
</ManSection>

<ManSection>
  <Prop Arg="E" Name="IsAlmostCanonicalIdeal"></Prop>
  <Description>
    <A>E</A> is an ideal of a numerical semigroup, say <M>S</M>. Set <M>I</M> to be a translation of <A>E</A> so that its conductor is the same as the conductor of <M>S</M>, and let <M>M</M> and <M>K</M> be the maximal and canonical ideals of <M>S</M>, respectively. Then <A>E</A> is almost canonical if <M>I-M=K-M</M> (see <Cite Key="gas-semigroups"></Cite>). Determines if <A>E</A> almost canonical.

<Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> IsAlmostSymmetric(s);
true
gap> IsAlmostCanonical(MaximalIdeal(s));
true
]]></Example>
    </Description>
</ManSection>

<ManSection>
    <Oper Arg="S" Name="TraceIdeal" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="TraceIdealOfNumericalSemigroup"></Func>
                    <Description>
		      <A>S</A> is a numerical semigroup.
                        Computes the trace ideal of <A>S</A> (<Cite Key="trace-ideal"></Cite>), that is,
                        <M>K+(<A>S</A>-K)</M>, with <M>K</M> the canonical ideal of <A>S</A>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> MinimalGenerators(TraceIdeal(s));
[ 3, 5, 7 ]
]]></Example>
    </Description>
</ManSection>


<ManSection>
    <Oper Arg="S" Name="TypeSequence" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="TypeSequenceOfNumericalSemigroup"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                         Computes the type sequence of a numerical semigroup. That is, the secuence <M>t_i(<A>S</A>)=\sharp(<A>S</A>(i)\setminus <A>S</A>(i-1))</M>, with <M><A>S</A>(i)=\{ s\in S\mid s\ge s_i\}</M> and <M>s_i</M> the <M>i</M>th element of <A>S</A>.
                         <P/>
                        This function is the implementation of the algorithm given in
                        <Cite Key="BDF97"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TypeSequence(s);
[ 13, 3, 4, 4, 7, 3, 3, 3, 2, 2, 2, 3, 3, 2, 4, 3, 2, 1, 3, 2, 1, 1, 2, 2, 1,
  1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
  1, 1, 1 ]
gap> s:=NumericalSemigroup(4,6,11);;
gap> TypeSequenceOfNumericalSemigroup(s);
[ 1, 1, 1, 1, 1, 1, 1 ]
]]></Example>
                    </Description>
</ManSection>

</Section>

<Section Label="sec:decomposition-irreducibles">
    <Heading>
        Decomposition into irreducibles
    </Heading>

    Let <M>I</M> be an ideal of a numerical semigroup <M>S</M>. We say that <M>I</M> is <M>\mathbb{Z}</M>-<E>irreducible</E> if it cannot be expressed as a finite intersection of other relative ideals properly containing it. Every ideal <M>I</M> can be expressed as an intersection of exactly <M>t</M> irreducible ideals of <M>S</M>, where <M>t</M> is the type of <M>I</M>. These irreducible ideals are unique and are known as the <E>irreducible <M>\mathbb{Z}</M>-components</E> of <M>I</M>.

    Recall that an ideal is integral (or proper) if it is contained in its ambient semigroup. We say that an integral ideal is <E>irreducible</E> if it cannot be expressed as an intersection of other proper integral ideals. Every integral ideal admits a unique decomposition into irredundant irreducible integral ideals. 

    <ManSection>
        <Oper Arg="I" Name="IrreducibleZComponents"></Oper>
        <Description>
            <A>I</A> is an ideal of a numerical semigroup. The output is the list of irreducible <M>\mathbb{Z}</M>-components of <A>I</A>. These are calculated using Proposition 24 in <Cite Key="nsapp2"></Cite>.
            <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> i:=[4,5]+s;;
gap> zc:=IrreducibleZComponents(i);
[ <Ideal of numerical semigroup>, <Ideal of numerical semigroup> ]
gap> List(zc,MinimalGenerators);
[ [ 2, 4 ], [ -2, 0 ] ]
gap> i=Intersection(zc);
true
]]></Example>
        </Description>
    </ManSection>

    <ManSection>
        <Oper Arg="I" Name="DecomposeIntegralIdealIntoIrreducibles"></Oper>
        <Description>
            <A>I</A> is an integral ideal of a numerical semigroup. The output is the list of irreducible integral ideals whose intersection is the unique irredundant decomposition of <A>I</A> into integral proper ideals. The computations are performed using Theorem 4 in <Cite Key="nsapp2"></Cite>.
            <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> i:=10+s;;
gap> di:=DecomposeIntegralIdealIntoIrreducibles(i);
[ <Ideal of numerical semigroup>, <Ideal of numerical semigroup> ]
gap> List(di,MinimalGenerators);
[ [ 8, 10 ], [ 10, 12 ] ]
gap> i=Intersection(di);
true
]]></Example>
        </Description>
    </ManSection>


</Section>

<Section>
                <Heading>
                    Blow ups and closures
                </Heading>
                The blow up of an ideal <M>I</M> of a numerical semigroup is the ideal  <M>\bigcup_{n\geq 0} n<A>I</A>-n<A>I</A></M>. In this section we provide functions to compute the blow up and related invariants.
                <ManSection>
                    <Func Arg="n, I" Name="HilbertFunctionOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup, <A>n</A> is a non negative integer. <A>I</A> must be contained in its ambient semigroup.
                        The output is the cardinality of the set <M><A>n</A><A>I</A>\setminus (<A>n</A>+1)<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[6,9,11]+NumericalSemigroup(6,9,11);;
gap> List([1..7],n->HilbertFunctionOfIdealOfNumericalSemigroup(n,I));
[ 3, 5, 6, 6, 6, 6, 6 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
                    <Attr Arg="I" Name="HilbertFunction"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup. <A>I</A> must be contained in its ambient semigroup (integral ideal).
                        The output is a function that maps to each <M>n</M> the cardinality of the set <M>n<A>I</A>\setminus (n+1)<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[6,9,11]+NumericalSemigroup(6,9,11);;
gap> List([1..7],n->HilbertFunction(I)(n));
[ 3, 5, 6, 6, 6, 6, 6 ]
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
                    <Oper Arg="I" Name="BlowUp" Label="for ideals of numerical semigroups"/>
                    <Func Arg="I" Name="BlowUpIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
The output is the ideal <M>\bigcup_{n\geq 0} n<A>I</A>-n<A>I</A></M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> BlowUp(I);
<Ideal of numerical semigroup>
gap> SmallElements(last);
[ 0, 2, 4, 6, 8 ]
gap> BlowUpIdealOfNumericalSemigroup(I);;
gap> SmallElementsOfIdealOfNumericalSemigroup(last);
[ 0, 2, 4, 6, 8 ]
]]></Example>
                    </Description>
                </ManSection>



                <ManSection>
                    <Attr Arg="I" Name="ReductionNumber" Label="for ideals of numerical semigroups"></Attr>
                    <Attr Arg="I" Name="ReductionNumberIdealNumericalSemigroup"></Attr>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the least integer
                        such that  <M>n <A>I</A> + i=(n+1)<A>I</A></M>, where <M>i=min(<A>I</A>)</M>.

                        <Example><![CDATA[
gap> I:=[0,2]+NumericalSemigroup(6,9,11);;
gap> ReductionNumber(I);
2
gap> ReductionNumberIdealNumericalSemigroup(I);
2
]]></Example>
                    </Description>
                </ManSection>





<ManSection>
                    <Oper Arg="S" Name="BlowUp" Label="for numerical semigroups"/>
                    <Func Arg="S" Name="BlowUpOfNumericalSemigroup"></Func>
                    <Description>
		      <A>S</A> is a numerical semigroup.
                        If <A>M</A> is the maximal ideal of the numerical semigroup, then
                        the output is the numerical semigroup
                        <M>\bigcup_{n\geq 0} n<A>M</A>-n<A>M</A></M>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BlowUp(s);
<Numerical semigroup with 10 generators>
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
gap> BlowUpOfNumericalSemigroup(s);;
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
gap> m:=MaximalIdeal(s);
<Ideal of numerical semigroup>
gap> BlowUp(m);
<Ideal of numerical semigroup>
gap> SmallElements(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
]]></Example>
                    </Description>
                </ManSection>
  <ManSection>
      <Func Name="LipmanSemigroup" Arg="S"></Func>
      <Description>
       This is just a synonym of <Ref Func="BlowUpOfNumericalSemigroup"/>.
      <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> LipmanSemigroup(s);
<Numerical semigroup with 10 generators>
gap> SmallElementsOfNumericalSemigroup(last);
[ 0, 5, 10, 12, 15, 17, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 36, 37, 39,
  40, 41, 42, 44 ]
]]></Example>

</Description>
</ManSection>


                <ManSection>
    <Oper Arg="I" Name="RatliffRushNumber"/>
                    <Func Arg="I" Name="RatliffRushNumberOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup <M>S</M>.
                        The output is the least integer
                        such that  <M>S\cap (n+1)<A>I</A>-n<A>I</A></M> is the Ratliff-Rush closure of <A>I</A> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> s:=NumericalSemigroup([9..17]);;
gap> i:=[9,10,12]+s;;
gap> RatliffRushNumber(i);
3
gap> ReductionNumber(i);
4
]]></Example>
                    </Description>
                </ManSection>


                <ManSection>
    <Oper Arg="I" Name="RatliffRushClosure"/>
                    <Func Arg="I" Name="RatliffRushClosureOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup <M>S</M>.
                        The output is the Ratliff-Rush closure of <A>I</A>:  <M>S\cap \bigcup_{n\in \mathbb{N}}(n+1)<A>I</A>-n<A>I</A></M> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(4,5,6,7);;
gap> i:=[4,5]+s;;
gap> MinimalGenerators(RatliffRushClosure(i));
[ 4, 5, 6, 7 ]
]]></Example>
                    </Description>
                </ManSection>

                <ManSection>
    <Oper Arg="I" Name="AsymptoticRatliffRushNumber"/>
                    <Func Arg="I" Name="AsymptoticRatliffRushNumberOfIdealOfNumericalSemigroup"></Func>
                    <Description>
                        <A>I</A> is an ideal of a numerical semigroup.
                        The output is the least <M>n</M> such that the Ratliff-Rush closure of <M>m<A>I</A></M> equals <M>m<A>I</A></M> for all <M>m\ge n</M> (see <Cite Key="DA-G-H"></Cite>).

                        <Example><![CDATA[
gap> i:=[4,5]+NumericalSemigroup([4..7]);;
gap> AsymptoticRatliffRushNumber(i);
3
]]></Example>
                    </Description>
                </ManSection>


<ManSection>
    <Oper Arg="S" Name="MultiplicitySequence"/>
    <Func Name="MultiplicitySequenceOfNumericalSemigroup" Arg="S"/>
    <Description>
     <A>S</A> is a numerical semigroup. The output is a list with the multiplicities of the sequence <M>S\subseteq L(S)\subseteq \cdots \subseteq \mathbb{N}</M>, where <M>L(\cdot)</M> means <Ref Func="LipmanSemigroup"/>.
    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5);;
gap> MultiplicitySequence(s);
[ 3, 2, 1 ]
gap> MultiplicitySequenceOfNumericalSemigroup(s);
[ 3, 2, 1 ]
]]></Example>
</Description>
</ManSection>


<ManSection>
    <Oper Arg="S" Name="MicroInvariants"/>
                    <Func Arg="S" Name="MicroInvariantsOfNumericalSemigroup"></Func>
                    <Description>
                        Returns the microinvariants of the numerical semigroup <A>S</A> defined
                        in <Cite Key="E01"></Cite>. For their computation we have used the formula
                        given in <Cite Key="BF06"></Cite>. The Apéry set of <A>S</A> and its
                        blow up are involved in this computation.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> bu:=BlowUpOfNumericalSemigroup(s);;
gap> ap:=AperyListOfNumericalSemigroupWRTElement(s,30);;
gap> apbu:=AperyListOfNumericalSemigroupWRTElement(bu,30);;
gap> (ap-apbu)/30;
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> MicroInvariants(s)=last;
true
gap> MicroInvariantsOfNumericalSemigroup(s)=MicroInvariants(s);
true
]]></Example>
                    </Description>
                </ManSection>




                <Heading>
                    Apéry sets of ideals of numerical semigroups
                </Heading>


                <ManSection>
                    <Oper Arg="I,n" Name="AperyList" Label="for ideals of numerical semigroups with respect to element"/>
                    <Func Arg="I,n" Name="AperyListOfIdealOfNumericalSemigroupWRTElement"></Func>
                    <Description>
<A>I</A> is an ideal and <A>n</A> is an integer.
 					Computes the set of elements <M>x</M> of <A>I</A>  such that <M>x-</M><A>n</A> is not in the ideal <A>I</A>,
					where <A>n</A> is supposed to be in the ambient semigroup of <A>I</A>.
					The element in the <M>i</M>th position of the output list (starting in 0) is congruent with <M>i</M> modulo <A>n</A>. See <Cite Key="ASICMNS"></Cite>

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> i:=[12,14]+s;;
gap> AperyList(i,10);
[ 40, 51, 12, 23, 14, 25, 36, 27, 38, 49 ]
gap> AperyListOfIdealOfNumericalSemigroupWRTElement(i,10);
[ 40, 51, 12, 23, 14, 25, 36, 27, 38, 49 ]
]]></Example>
                     </Description>
                </ManSection>

                <ManSection>
                    <Oper Arg="I" Name="AperyList" Label="for ideals of numerical semigroups with respect to multiplicity"/>
                    <Description>
                    <A>I</A> is an ideal. Computes the Apéry list of <A>I</A> with respect to the multiplicity of its ambient numerical semigroup.

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(5,7,9);;
gap> i:=[0,1,2]+s;;
gap> AperyList(i);
[ 0, 1, 2, 8, 9 ]
]]></Example>
                     </Description>
                </ManSection>



                <ManSection>
                    <Oper Arg="S" Name="AperyTable"/>
                    <Func Arg="s" Name="AperyTableOfNumericalSemigroup"></Func>
                    <Description>

				 Computes the Apéry table associated to the numerical semigroup <A>s</A> as explained in <Cite Key="CJZ"></Cite>,
				 that is, a list containing the Apéry list of <A>s</A> with respect to its multiplicity and the Apéry lists of <M>kM</M>
				(with <M>M</M> the maximal ideal of <A>s</A>) with respect to the multiplicity of <A>s</A>, for <M>k\in\{1,\ldots,r\}</M>,
				where <M>r</M> is the reduction number of <M>M</M>  (see <Ref Func="ReductionNumberIdealNumericalSemigroup"/>).

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(10,11,13);;
gap> AperyTable(s);
[ [ 0, 11, 22, 13, 24, 35, 26, 37, 48, 39 ],
  [ 10, 11, 22, 13, 24, 35, 26, 37, 48, 39 ],
  [ 20, 21, 22, 23, 24, 35, 26, 37, 48, 39 ],
  [ 30, 31, 32, 33, 34, 35, 36, 37, 48, 39 ],
  [ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 ] ]
gap> AperyTableOfNumericalSemigroup(s) = AperyTable(s);
true
]]></Example>
                     </Description>
                </ManSection>

                <ManSection>
                    <Func Arg="i, is" Name="StarClosureOfIdealOfNumericalSemigroup"></Func>
                    <Description>

						<A>i</A> is an ideal and <A>is</A> is a set of ideals (all from the same numerical semigroup<M>s</M>).
						The output is <M>i^{*_{is}}</M>, where <M>*_{is}</M> is the star operation generated by <A>is</A>: <M>(s-(s-i))\bigcap_{k\in is} (k-(k-i))</M>.
						The implementation uses Section 3 of <Cite Key="MR3354072"></Cite>.

                       <Example><![CDATA[
gap> s:=NumericalSemigroup(3,5,7);;
gap> StarClosureOfIdealOfNumericalSemigroup([0,2]+s,[[0,4]+s]);;
gap> MinimalGenerators(last);
[ 0, 2, 4 ]
]]></Example>
                     </Description>
                </ManSection>


</Section>


<Section Label="sec:PatternsIdeals">
<Heading>
    Patterns for ideals
</Heading>

In this section we document the functions implemented by K. Stokes related to patterns of ideals in numerical semigroups. The correctness of the algorithms can be found in <Cite Key="Stokes"></Cite>.


<ManSection>
  <Func Arg="p" Name="IsAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns <C>true</C> or <C>false</C> depending if the pattern is admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,1,-1]);
true
gap> IsAdmissiblePattern([1,-2]);
false
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p" Name="IsStronglyAdmissiblePattern"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a pattern. <P/>

    Returns <C>true</C> or <C>false</C> depending if the pattern is strongly admissible or not  (see <Cite Key="BA-GS"></Cite>).

    <Example><![CDATA[
gap> IsAdmissiblePattern([1,-1]);
true
gap> IsStronglyAdmissiblePattern([1,-1]);
false
gap> IsStronglyAdmissiblePattern([1,1,-1]);
true
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="I,T" Name="AsIdealOfNumericalSemigroup"></Func>
  <Description>

    <A>I</A> is an ideal of a numerical semigroup <M>S</M>, and <A>T</A> is a numerical semigroup. Detects if <A>I</A> is an ideal of <A>T</A> and contained in <A>T</A> (integral ideal), and if so, returns <A>I</A> as an ideal of <A>T</A>. It returns <C>fail</C> if <A>I</A> is an ideal of some semigroup but not an integral ideal of <A>T</A>.

    <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> t:=NumericalSemigroup(10,11,14);;
gap> AsIdealOfNumericalSemigroup(10+s,t);
fail
gap> AsIdealOfNumericalSemigroup(100+s,t);
<Ideal of numerical semigroup>
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,C" Name="BoundForConductorOfImageOfPattern"></Func>
  <Description>

     <A>p</A> is the list of integers that are the coefficients of an admissible pattern. <A>C</A> is a positive integer.

     Calculates an upper bound of the smallest element <M>K</M> in <M>p(I)</M> such that all integers larger than <M>K</M> belong to <M>p(I)</M>, where <M>I</M> is an ideal of a
numerical semigroup. Instead of taking <M>I</M> as parameter, the function takes <M>C</M>, which is assumed to be the conductor of <M>I</M>.
    <Example><![CDATA[
gap> BoundForConductorOfImageOfPattern([1,1,-1],10);
10
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,I" Name="ApplyPatternToIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> is an ideal of a numerical semigroup.<P/>

    Outputs <M>p(I)</M>, represented as <C>[d,p(I)/d]</C>, where <C>d</C > is the gcd of the coefficients of <A>p</A>. All elements of <M>p(I)</M> are divisible by <M>d</M>, and <M>p(I)/d</M> is an ideal of some numerical semigroup. It is returned as the maximal ideal of the numerical semigroup <M>p(I)/d \cup \{0\}</M>. The ambient numerical semigroup can later be changed with the function <C>AsIdealOfNumericalSemigroup</C>.


     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=10+s;;
gap> ApplyPatternToIdeal([1,1,-1],i);
[ 1, <Ideal of numerical semigroup> ]
]]></Example>
  </Description>
</ManSection>


<ManSection>
  <Func Arg="p,S" Name="ApplyPatternToNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> is  a numerical semigroup.<P/>

    Outputs <C>ApplyPatternToIdeal(p,0+S)</C>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> ApplyPatternToNumericalSemigroup([1,1,-1],s);
[ 1, <Ideal of numerical semigroup> ]
gap> SmallElements(last[2]);
[ 0, 3, 5 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,I,J" Name="IsAdmittedPatternByIdeal"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>I</A> and <A>J</A> are ideals of certain numerical semigroups.<P/>


    Tests whether or not <M>p(I)</M> is contained in <A>J</A>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> i:=[3,5]+s;;
gap> IsAdmittedPatternByIdeal([1,1,-1],i,i);
false
gap> IsAdmittedPatternByIdeal([1,1,-1],i,0+s);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="p,S,T" Name="IsAdmittedPatternByNumericalSemigroup"></Func>
  <Description>

    <A>p</A> is the list of integers that are the coefficients of a strongly admissible pattern. <A>S</A> and <A>T</A> are numerical semigroups.<P/>


    Tests whether or not <M>p(S)</M> is contained in <A>T</A>.

     <Example><![CDATA[
gap> s:=NumericalSemigroup(3,7,5);;
gap> IsAdmittedPatternByNumericalSemigroup([1,1,-1],s,s);
true
gap> IsArfNumericalSemigroup(s);
true
]]></Example>
  </Description>
</ManSection>



</Section>

<Section>
  <Heading>Graded associated ring of numerical semigroup</Heading>

  This section contains several functions to test properties of the graded (with respect to the maximal ideal) semigroup ring <M>\mathbb{K}[\![S]\!]</M> (with <M>S</M> a numerical semigroup).

  <ManSection>
                      <Prop Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCM"></Prop>
                      <Description>
                          <A>S</A> is a numerical semigroup.
                          Returns <C>true</C> if the graded ring associated to <M>K[[<A>S</A>]]</M>
                          is Cohen-Macaulay, and <C>false</C> otherwise.
                          This test is the implementation of the algorithm given in
                          <Cite Key="BF06"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupBuchsbaum"/>.
                          <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
false
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 4, 4, 3, 2, 1, 3, 4, 4, 3, 2, 3, 1, 4, 4, 3, 3, 1, 4, 4, 4, 3, 2, 4, 2,
  5, 4, 3, 3, 2 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,30),
> w->MaximumDegreeOfElementWRTNumericalSemigroup (w,s));
[ 0, 1, 4, 1, 2, 1, 3, 1, 4, 3, 2, 3, 1, 1, 4, 3, 3, 1, 4, 1, 4, 3, 2, 4, 2,
  5, 4, 3, 1, 2 ]
gap> last=last2;
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCM(s);
true
gap> MicroInvariantsOfNumericalSemigroup(s);
[ 0, 2, 1, 1 ]
gap> List(AperyListOfNumericalSemigroupWRTElement(s,4),
> w->MaximumDegreeOfElementWRTNumericalSemigroup(w,s));
[ 0, 2, 1, 1 ]
  ]]></Example>
                      </Description>
                  </ManSection>

<ManSection>
                    <Prop Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupBuchsbaum"></Prop>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the graded ring associated to <M>K[\![<A>S</A>]\!]</M>
                        is Buchsbaum, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in <Cite Key="DA-M-M"></Cite>.


                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
                    </Description>
</ManSection>


<ManSection>
  <Func Arg="S" Name="TorsionOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the set of elements in the numerical semigroup <A>S</A> corresponding to a <M>\mathbb{K}</M>-basis of the torsion submodule of the associated graded ring of the numerical semigroup ring <M>\mathbb{K}[\![S]\!]</M>. It uses the Apery table as explained in <Cite Key="CJZ"></Cite>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> TorsionOfAssociatedGradedRingNumericalSemigroup(s);
[ 181, 153, 157, 193, 169, 148 ]
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Func Arg="S" Name="BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup"></Func>
  <Description>

    <A>S</A> is a numerical semigroup.
    <P/>

    This function returns the smallest non-negative integer <M>k</M> for which the associated graded ring <M>G</M> of a given numerical semigroup ring is <M>k</M>-Buchsbaum, that is, the least <M>k</M> for which the torsion submodule of <M>G</M> is annihilated by the <M>k</M>-th power of the homogeneous maximal ideal of <M>G</M>.

<Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> BuchsbaumNumberOfAssociatedGradedRingNumericalSemigroup(s);
1
gap> IsGradedAssociatedRingNumericalSemigroupBuchsbaum(s);
true
]]></Example>
  </Description>
</ManSection>


<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupGorenstein"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the graded ring associated to <M>K[[<A>S</A>]]</M>
                        is Gorenstein, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DA-M-S"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupCM"/>, <Ref Func="IsMpureNumericalSemigroup"/>, and <Ref Func="IsSymmetricNumericalSemigroup"/>.
                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupGorenstein(s);
true
]]></Example>
                    </Description>
</ManSection>


<!--the functions below first appeared in version 0.98-->
<ManSection>
                    <Func Arg="S" Name="IsGradedAssociatedRingNumericalSemigroupCI"></Func>
                    <Description>

                        <A>S</A> is a numerical semigroup.
                        <P/>

                        Returns <C>true</C> if the Complete Intersection property of the associated graded ring of a numerical semigroup ring associated to <M>K[[<A>S</A>]]</M>, and <C>false</C> otherwise.
                        This test is the implementation of the algorithm given in
                        <Cite Key="DAMSwhen"></Cite>.

                        <P/>
                        This filter implies <Ref Func="IsGradedAssociatedRingNumericalSemigroupGorenstein"/> and <Ref Func="IsAperySetGammaRectangular"/>.

                        <Example><![CDATA[
gap> s:=NumericalSemigroup(30, 35, 42, 47, 148, 153, 157, 169, 181, 193);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
false
gap> s:=NumericalSemigroup(4,6,11);;
gap> IsGradedAssociatedRingNumericalSemigroupCI(s);
true
]]></Example>
                    </Description>
                </ManSection>


</Section>
